{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"bring \u00b6 Manage files declaratively and deterministically, with minimal configuration. bring is the package manager for generic files you never knew you wanted. It lets you enrich your own as well as other peoples published files with metadata, which in turn allows you to specify the layout of folder structures in a very concise and easy to manage way. TODO: EXAMPLE","title":"**bring**"},{"location":"#bring","text":"Manage files declaratively and deterministically, with minimal configuration. bring is the package manager for generic files you never knew you wanted. It lets you enrich your own as well as other peoples published files with metadata, which in turn allows you to specify the layout of folder structures in a very concise and easy to manage way. TODO: EXAMPLE","title":"bring"},{"location":"about/","text":"Why you shouldn't use bring \u00b6 In the interest of not wasting your time, nor mine, here's a list of reasons to help you decide whether you should or should not try out bring . I do hope this list will get shorter over time though, so maybe check back here every now and then if you are 'interested in principle'... Missing features \u00b6 no hashes for downloaded files supported (yet) no support for secret values like passwords, access tokens, etc (yet) State of the code \u00b6 Currently bring is in a late alpha state, I'd say. It's usable, and works most of the time, but you should expect some issues every now and then. Here are some of the things I'd like to fix before I'd consider releasing the first beta version: confusing or non-informative error messages documentation in general, but especially in-code test coverage of bring and it's dependencies pockets of complexity that turned out to be unnecessary, and should be removed or simplified Design and technologies used \u00b6 bring is written in object-oriented Python. It is -- some wil/might say -- over-engineered for what it is, with quite a few abstract class-hierarchies and other (arguable) 'anti-patterns' that could have been avoided if one was interested in more compact and maintainable code. I chose this design and its trade-offs deliberately, and am well aware of the disadvantages some of those decisions bring with them. bring is really only a side-product for a bigger application I have in mind, which is the main reason for most of kind of the decisions I mentioned. So, if a terse and minimal code-base with hardly any levels of abstractions is important to you, bring is most likely not for you... bring uses 'async'. A lot. That wasn't a deliberate decision when I started out, but I figured it can't hurt and since it's fully supported now... And then one thing lead to another, one 'async' function required the parent to also be 'async', and so on... So, after writing a lot of code I'm not so sure anymore whether I should have been more conservative and just use threading, or if the alternative would have been much worse, with race-conditions all over the place... Overall, I'm happy enough how the code turned out, so I'm not going to change anything now. And speed-wise I think bring does fairly well, for a Python application. But still, I can see how people could have strong opinions about something like this, so I thought I'd mention it. Also, all the examples I use in the documentation show how package descriptions are written using yaml . I can't -- for the life of me -- figure out why; but some people out there seem to have a very strong aversion against yaml . I can only assume they used it in places where they shouldnn't have, or were forced to, or whatever. Anyway, if you have an opinion about 'yaml', don't use bring . It's just easier for both of us to not have to talk about something like this. License \u00b6 bring uses a very strong copyleft license, The Parity Public License . For now, anyway. Currently, I'm not sure how to best license bring (as that will also have implications on the bigger application I mention above), which is why I decided it makes the most sense to start with the 'strongest' possible license. It'll be easy to move to more permissive licenses later on. But if I start with something like the Apache license, or BSD, I won't be able to use a more restrictive license later on, at least not for the existing code. You should read the license yourself, its a quick read and easy to parse. But in short: Parity only allows you to use code licensed with it in combination with software that is also licensed with Parity, or a license that is more permissive (which all 'standard' open source licenses are). Parity is not technically 'open-source' itself, mainly because it discriminates against field of endeavor. The specific field of endeavor I want it to discriminate against is \"using bring to create non-open source, commercial code\". I find that fair enough, but am aware that there are some negative consequences, and there could be collateral damage that I do not intend to happen. I'd ask you to decide for yourself whether you also find that fair enough, and whether the consequences are acceptable or not. I welcome constructive feedback, but please keep it civil if you have some. To remove most of the friction for people who want to use bring for personal use, bring is also licensed under the Properity Public License , which allows non-commerical usage. For everyone else, I'll be offering private licenses for sale. Should there be any interest. Which I judge to be fairly unlikely, but who knows, it would be great if there was... Contact me.","title":"About"},{"location":"about/#why-you-shouldnt-use-bring","text":"In the interest of not wasting your time, nor mine, here's a list of reasons to help you decide whether you should or should not try out bring . I do hope this list will get shorter over time though, so maybe check back here every now and then if you are 'interested in principle'...","title":"Why you shouldn't use bring"},{"location":"about/#missing-features","text":"no hashes for downloaded files supported (yet) no support for secret values like passwords, access tokens, etc (yet)","title":"Missing features"},{"location":"about/#state-of-the-code","text":"Currently bring is in a late alpha state, I'd say. It's usable, and works most of the time, but you should expect some issues every now and then. Here are some of the things I'd like to fix before I'd consider releasing the first beta version: confusing or non-informative error messages documentation in general, but especially in-code test coverage of bring and it's dependencies pockets of complexity that turned out to be unnecessary, and should be removed or simplified","title":"State of the code"},{"location":"about/#design-and-technologies-used","text":"bring is written in object-oriented Python. It is -- some wil/might say -- over-engineered for what it is, with quite a few abstract class-hierarchies and other (arguable) 'anti-patterns' that could have been avoided if one was interested in more compact and maintainable code. I chose this design and its trade-offs deliberately, and am well aware of the disadvantages some of those decisions bring with them. bring is really only a side-product for a bigger application I have in mind, which is the main reason for most of kind of the decisions I mentioned. So, if a terse and minimal code-base with hardly any levels of abstractions is important to you, bring is most likely not for you... bring uses 'async'. A lot. That wasn't a deliberate decision when I started out, but I figured it can't hurt and since it's fully supported now... And then one thing lead to another, one 'async' function required the parent to also be 'async', and so on... So, after writing a lot of code I'm not so sure anymore whether I should have been more conservative and just use threading, or if the alternative would have been much worse, with race-conditions all over the place... Overall, I'm happy enough how the code turned out, so I'm not going to change anything now. And speed-wise I think bring does fairly well, for a Python application. But still, I can see how people could have strong opinions about something like this, so I thought I'd mention it. Also, all the examples I use in the documentation show how package descriptions are written using yaml . I can't -- for the life of me -- figure out why; but some people out there seem to have a very strong aversion against yaml . I can only assume they used it in places where they shouldnn't have, or were forced to, or whatever. Anyway, if you have an opinion about 'yaml', don't use bring . It's just easier for both of us to not have to talk about something like this.","title":"Design and technologies used"},{"location":"about/#license","text":"bring uses a very strong copyleft license, The Parity Public License . For now, anyway. Currently, I'm not sure how to best license bring (as that will also have implications on the bigger application I mention above), which is why I decided it makes the most sense to start with the 'strongest' possible license. It'll be easy to move to more permissive licenses later on. But if I start with something like the Apache license, or BSD, I won't be able to use a more restrictive license later on, at least not for the existing code. You should read the license yourself, its a quick read and easy to parse. But in short: Parity only allows you to use code licensed with it in combination with software that is also licensed with Parity, or a license that is more permissive (which all 'standard' open source licenses are). Parity is not technically 'open-source' itself, mainly because it discriminates against field of endeavor. The specific field of endeavor I want it to discriminate against is \"using bring to create non-open source, commercial code\". I find that fair enough, but am aware that there are some negative consequences, and there could be collateral damage that I do not intend to happen. I'd ask you to decide for yourself whether you also find that fair enough, and whether the consequences are acceptable or not. I welcome constructive feedback, but please keep it civil if you have some. To remove most of the friction for people who want to use bring for personal use, bring is also licensed under the Properity Public License , which allows non-commerical usage. For everyone else, I'll be offering private licenses for sale. Should there be any interest. Which I judge to be fairly unlikely, but who knows, it would be great if there was... Contact me.","title":"License"},{"location":"api-documentation/","text":"bring \u00b6 log \u00b6 Top-level package for bring. bring.utils \u00b6 find_version \u00b6 find_version ( vars : Mapping [ str , str ], metadata : PkgMetadata , var_aliases_replaced = False ) -> Optional [ PkgVersion ] Return details about one version item of a package, using the provided vars to find one (or the first) version that matches most/all of the provided vars. Arguments : vars : User provided vars metadata : the package metadata bring.utils.github \u00b6 bring.utils.git \u00b6 bring.utils.defaults \u00b6 bring.utils.indexes \u00b6 bring.utils.pkgs \u00b6 bring.utils.pkg_spec \u00b6 bring.utils.paths \u00b6 bring.utils.system_info \u00b6 bring.utils.args \u00b6 bring.utils.doc \u00b6 bring.utils.gitlab \u00b6 bring.bring \u00b6 Main module. Bring Objects \u00b6 class Bring ( SimpleTing ) get_pkg_map \u00b6 | async get_pkg_map ( * indexes ) -> Mapping [ str , Mapping [ str , PkgTing ]] Get all pkgs, per available (or requested) indexes. get_full_package_name \u00b6 | async get_full_package_name ( package_name : str ) -> Optional [ str ] Get the full package name of a provided string. Mainly this is used to make sure there is an 'index-components' to a package name. The default index will be used if none was present. If the string is not a valid package name can't otherwise not be processed 'None' is returned. bring.defaults \u00b6 bring.pkg_index \u00b6 bring.pkg_index.gitservice_user_index \u00b6 bring.pkg_index.folder_index \u00b6 bring.pkg_index.static_index \u00b6 bring.pkg_index.utils \u00b6 diff_packages \u00b6 async diff_packages ( index_orig : BringIndexTing , index_new : BringIndexTing ) -> Mapping [ str , Any ] Diffs the packages of two indexes. This does not update any of the indexes, if that is the desired behaviour, do that beforehand. bring.pkg_index.config \u00b6 bring.pkg_index.index \u00b6 BringIndexTing Objects \u00b6 class BringIndexTing ( InheriTing , SimpleTing ) update \u00b6 | async update ( in_background : bool = False ) -> None Updates pkg metadata. bring.pkg_index.factory \u00b6 bring.pkg_index.pkgs \u00b6 bring.pkg_index.gitlab_user_index \u00b6 bring.pkg_index.github_user_index \u00b6 bring._meta \u00b6 bring.interfaces \u00b6 bring.interfaces.cli \u00b6 bring.interfaces.cli.process \u00b6 bring.interfaces.cli.list_pkgs \u00b6 BringListPkgsGroup Objects \u00b6 class BringListPkgsGroup ( FrklBaseCommand ) format_commands \u00b6 | format_commands ( ctx , formatter ) Extra format methods for multi methods that adds all the commands after the options. bring.interfaces.cli.utils \u00b6 create_pkg_list_for_help \u00b6 async create_pkg_list_for_help ( bring : Bring , indicate_optional_index : bool = True ) -> List [ Tuple [ str , str ]] Extra format methods for multi methods that adds all the commands after the options. bring.interfaces.cli.config \u00b6 BringContextGroup Objects \u00b6 class BringContextGroup ( FrklBaseCommand ) __init__ \u00b6 | __init__ ( bring_config : BringConfig , name : str = None , ** kwargs ) Install BringContextCommands Objects \u00b6 class BringContextCommands ( FrklBaseCommand ) __init__ \u00b6 | __init__ ( bring_config : BringConfig , bring_context : ConfigTing , name : str = None , ** kwargs ) Install bring.interfaces.cli.differ \u00b6 dev \u00b6 @click . group () @click . pass_context dev ( ctx ) Helper tasks for development. differ \u00b6 @dev . command () @click . argument ( \"path\" , nargs = 1 ) @click . pass_context async differ ( ctx , path ) Clear the bring cache dir in the relevant locaiont (e.g. '~/.cache/bring' on Linux). bring.interfaces.cli.cli \u00b6 bring.interfaces.cli.plugin \u00b6 plugin \u00b6 @click . command () @click . pass_context @handle_exc_async async plugin ( ctx ) Clear the bring cache dir in the relevant locaiont (e.g. '~/.cache/bring' on Linux). bring.interfaces.cli.dev \u00b6 BringDevGroup Objects \u00b6 class BringDevGroup ( FrklBaseCommand ) __init__ \u00b6 | __init__ ( bring : Bring , name : str = None , ** kwargs ) Install bring.interfaces.cli.command_group \u00b6 bring.interfaces.cli.commands \u00b6 bring.interfaces.cli.commands.export_index \u00b6 bring.interfaces.cli.commands.explain \u00b6 bring.interfaces.cli.commands.install \u00b6 BringInstallGroup Objects \u00b6 class BringInstallGroup ( FrklBaseCommand ) __init__ \u00b6 | __init__ ( bring : Bring , name : str = None , ** kwargs ) Install format_commands \u00b6 | format_commands ( ctx , formatter ) Extra format methods for multi methods that adds all the commands after the options. bring.interfaces.cli.commands.update \u00b6 bring.interfaces.cli.commands.create \u00b6 BringCreateGroup Objects \u00b6 class BringCreateGroup ( FrklBaseCommand ) __init__ \u00b6 | __init__ ( name : str = None , ** kwargs ) Command to create bring-related elements. BringCreatePkgDescGroup Objects \u00b6 class BringCreatePkgDescGroup ( FrklBaseCommand ) __init__ \u00b6 | __init__ ( name : str = None , ** kwargs ) Command to create bring-related elements. bring.interfaces.cli.commands.doc \u00b6 BringDocGroup Objects \u00b6 class BringDocGroup ( FrklBaseCommand ) __init__ \u00b6 | __init__ ( freckles : Freckles , name : str = \"doc\" , ** kwargs ) Install bring.frecklets \u00b6 bring.frecklets.template \u00b6 bring.frecklets.install_pkg \u00b6 bring.frecklets.install_pkg.tasks \u00b6 bring.frecklets.install_pkg.frecklet \u00b6 bring.frecklets.install_assembly \u00b6 bring.frecklets.install_assembly.assembly \u00b6 bring.frecklets.install_assembly.tasks \u00b6 bring.frecklets.install_assembly.frecklet \u00b6 bring.plugins \u00b6 bring.plugins.templating \u00b6 bring.plugins.templating.cli \u00b6 bring.plugins.templating.core \u00b6 bring.config \u00b6 ConfigTing Objects \u00b6 class ConfigTing ( InheriTing , SimpleTing ) Represents a config profile. Config profiles can inherit from other profiles, overwriting one or several of the parent key/value pairs. bring.config.folder_config \u00b6 FolderConfigProfilesTing Objects \u00b6 class FolderConfigProfilesTing ( SimpleTing ) __init__ \u00b6 | __init__ ( name : str , meta : TingMeta , config_path : str , config_file_ext : str = \"config\" ) A class to hold a set of ConfigTings, and gives access to them and their config dicts. get_contexts \u00b6 | async get_contexts ( update : bool = False ) -> Mapping [ str , ConfigTing ] Get all available config profiles. get_config_dicts \u00b6 | async get_config_dicts ( update : bool = False ) -> Mapping [ str , Mapping [ str , Any ]] Retrun the values of all available config profiles. bring.config.bring_config \u00b6 BringConfig Objects \u00b6 class BringConfig ( object ) Wrapper to manage and access the configuration of a Bring instance. bring.pkg_types \u00b6 PkgType Objects \u00b6 class PkgType (, metaclass = ABCMeta ) Abstract base class which acts as an adapter to retrieve package information using the 'source' key in bring pkg metadata. __init__ \u00b6 | __init__ ( arg_hive : ArgHive , ** config : Any ) The base class to inherit from to create package metadata of a certain type. Supported config keys (so far): metadata_max_age : age of metadata in seconds that is condsidered valid (set to 0 to always invalidate/re-load metadata, -1 to never invalidate) get_args \u00b6 | @abstractmethod | get_args () -> Mapping [ str , Mapping [ str , Any ]] A dictionary describing which arguments are necessary to create a package of this type. get_unique_source_id \u00b6 | get_unique_source_id ( source_details : Mapping [ str , Any ]) -> str Return a calculated unique id for a package. Implement your own '_get_unique_type_source_id' method for a type specific, meaningful id. If that method is not overwritten, a 'deephash' of the source dictionary is used. This is used mainly for caching purposes. get_seed_data \u00b6 | async get_seed_data ( source_details : Mapping [ str , Any ]) Overwrite to provide seed data for a pkg. This is mostly used for the 'bring-pkg' type, in order to retrieve parent metadata. Currently only 'info' and 'labels' keys are supported. get_pkg_metadata \u00b6 | async get_pkg_metadata ( source_details : Union [ str , Mapping [ str , Any ]], override_config : Optional [ Mapping [ str , Any ]] = None ) -> PkgMetadata Return metadata of a bring package, specified via the provided source details and current index. If a string is provided as 'source_details', it'll be converted into a dict like: {\"url\": <source_details>} . Arguments : source_details - the pkg-type specific details that are needed to create the package metadata override_config - optional configuration to adjust pkg metadata creation (e.g. cache invalidation, etc). overrides the default pkg-type config. Returns : PkgMetadata - the package metadata process_vars \u00b6 | async process_vars ( source_args : Mapping [ str , Any ], pkg_args : Mapping [ str , Any ], mogrifiers : Union [ Iterable , Mapping ], source_vars : Mapping [ str , Any ], versions : List [ PkgVersion ], aliases : Mapping [ str , Mapping [ str , str ]]) -> Mapping [ str , Any ] Return the (remaining) args a user can specify to select a version or mogrify options. \u00b6 Source args can contain more arguments than will eventually be used/displayed to the user. Arguments : source_args : dictionary of args to describe the type/schema of an argument pkg_args : a dictionary of automatically created args by a specific resolver. Those will be used as base, but will be overwritten by anything in 'source_args' mogrifiers : the 'mogrify' section of the pkg 'source' source_vars : vars that are hardcoded in the 'source' section of a package, can also contain templates versions : all avaailable versions of a package aliases : a dictionary of value aliases that can be used by the user instead of the 'real' ones. Aliases are per arg name. Returns : a dictionary with 3 keys: args, version_vars, mogrify_vars bring.pkg_types.git_files \u00b6 GitFiles Objects \u00b6 class GitFiles ( PkgType ) A package type to retrieve one or several files from a git repository. Under the hood, this uses the git archive command to retrieve a zipped archive of the requested files, so when specifying the git url, make sure to either use the git or ssh protocol, or, if using https , that the remote server supports Smart HTTP (GitHub, for example, does not as far as I know). To filter out certain tags you don't want to end up as 'version's, you can use the tag_filter key, and specify a regular explression of 'allowed' tags. Templated file paths are not supported currently, but will be in the future. examples: - gitlab.bring-indexes.example-index.bring_readme bring.pkg_types.git_repo \u00b6 GitRepo Objects \u00b6 class GitRepo ( PkgType ) A package that represents a git repository and its content. The only argument required is the git repository url. bring will download and cache (unless otherwise configured) the whole repo. Depending on the repository size this might or might not be desirable. If the repository is large, and only one or a few files are wanted, it is probably better to use the git_files (or github_files , gitlab_files , ...) package type, as this only downloads the files needed. If one git repository is the shared source for multiple packages, this package type might be the better choice though, since it will be only downloaded and cached once, and retrieval of each of those packages is quicker (since the git repository is cached locally, and only a git checkout is necessary to retrieve a specific version). By default, all tags and branches will be used as version names. If ' use_commits_as_versions ' is set to ' true ', also the commit hashes will be used. An alias ' latest ' will be added, pointing to the latest tag, or, in case no tags exist, to the 'master' branch. Examples : scripts.bashtop bring.pkg_types.folder \u00b6 Folder Objects \u00b6 class Folder ( PkgType ) A package type to represent a local folder. This is mostly used in local development, documentation still to be done... bring.pkg_types.gitlab_files \u00b6 GitFiles Objects \u00b6 class GitFiles ( PkgType ) A package type to retrieve one or several files from a git repository that is hosted on GitLab . This package type directly downloads the required files from GitLab, without retrieving the repository itself first. This way of accessing files is advantageous if you only need a few, small files, and the repository itself is on the larger side. If this is not the case, consider using the ' git_repo ' package type. File-paths specified in the files argument can contain template place-holders (like: deploy/${provider}/config.json ). If that is the case, you need to provide a list of possible values for each of the included placeholders in the template_values key (check the example below). examples: - gitlab.bring-indexes.example-index.example_file1 bring.pkg_types.github_release \u00b6 GithubRelease Objects \u00b6 class GithubRelease ( PkgType ) A package type that tracks GitHub release artefacts. To be able to get a list of all releases and their metadata, a package needs to specify the github user- and repo-names, as well as a regex to parse the release urls and compute the variables (version, architecture, os, etc.) involved to assemble a list of versions for a package. This is a barebones example for a source definition for the fd application: source : type : github-release user_name : sharkdp repo_name : fd url_regex : 'https://github.com/.*/releases/download/v(?P<version>.*)/.*-v(?P=version)-(?P<arch>[^-]*)-(?P<os>[^.]*)\\\\..*$' More than one such regular expressions can be provided (in which case the value for url_regex should be a list), all matches for all regexes will be added to the resulting list. Most of the regexes for different packages look fairly similar, but unfortunately Github release-urls don't follow a standard, which makes it impossible to come up with one that can be used for all of them. bring comes with a default regex that works for quite a few Github projects (and almost for a lot of others). In fact, the regex in the example above is the default regex that will be used if no ' url_regex ' value is provided, and it so happens that it works for ' fd ' (which means we could have omitted it for that particular application). Nonetheless, whoever creates a new package manifest needs to manually verify whether the default regex works, and then adjust or create a totally different one if necessary. examples: - binaries.k3d - kubernetes.cert-manager bring.pkg_types.github_files \u00b6 GitFiles Objects \u00b6 class GitFiles ( PkgType ) A package type to retrieve one or several files from a git repository that is hosted on GitHub . This package type directly downloads the required files from GitHub, without downloading the repository itself first. This way of accessing files is advantageous if you only need a few, small files, and the repository itself is on the larger side. If this is not the case, consider using the ' git_repo ' package type. File-paths specified in the files argument can contain template place-holders (like: deploy/${provider}/config.json ). If that is the case, you need to provide a list of possible values for each of the included placeholders in the template_values key (check the example below). examples: - kubernetes.ingress-nginx bring.pkg_types.template_url \u00b6 TemplateUrlResolver Objects \u00b6 class TemplateUrlResolver ( PkgType ) A package type to resolve packages whose artifacts are published with static urls that can be templated. All values of all template variables are combined with each of the other template variables to create a matrix of possible combinations. In some cases some of those combinations are not valid, and lead to a url that does not resolve to a file to download. At this time, there is nothing that can be done about it and the user will see an error message. Examples : binaries.kubectl binaries.helm bring.doc \u00b6 bring.doc.index \u00b6 bring.doc.plugins \u00b6 bring.doc.args \u00b6 bring.doc.pkg \u00b6 bring.pkg \u00b6 PkgTing Objects \u00b6 class PkgTing ( SimpleTing ) get_metadata \u00b6 | @abstractmethod | async get_metadata ( config : Optional [ Mapping [ str , Any ]] = None , register_task : bool = False ) -> PkgMetadata Return metadata associated with this package. DynamicPkgTing Objects \u00b6 class DynamicPkgTing ( PkgTing ) get_metadata \u00b6 | async get_metadata ( config : Optional [ Mapping [ str , Any ]] = None , register_task : bool = False ) -> PkgMetadata Return metadata associated with this package. bring.mogrify \u00b6 Mogrifier Objects \u00b6 class Mogrifier ( Task , SimpleTing ) The base class to extend to implement a 'Mogrifier'. A mogrifier is one part of a pipeline, usually taking an input folder, along other arguments, and providing an output folder path as result. Which in turn is used by the subsequent Mogrifier as input, etc. There are a few special cases, for example the 'download' mogrifier which takes a url as input and provides a path to a file (not folder) as output, or the 'extract' mogrifier which takes an (archive) file as input and provides a folder path as output. Currently there is not much checking whether Mogrifiers that are put together fit each others input/output arguments, but that will be implemented at some stage. So, for now, it's the users responsibility to assemble mogrifier pipelines that make sense. An implementation of a Mogrifier can either provide class-level attributes '_provides' and '_requires', or implement the 'provides()' and 'requires()' instance or class level methods. This method will be only read once per Ting prototype (TODO: reference), so make sure to not process any calculated values in there. Transmogritory Objects \u00b6 class Transmogritory ( SimpleTing ) Registry that holds all mogrify plugins. bring.mogrify.template \u00b6 bring.mogrify.transform_folder \u00b6 FolderContentMogrifier Objects \u00b6 class FolderContentMogrifier ( SimpleMogrifier ) Merge multiple folders into a single one, using one of the available merge strategies. This mogrifier is used internally, and, for now, can't be used in user-created mogrifier lists. bring.mogrify.parallel_pkg_merge \u00b6 bring.mogrify.set_mode \u00b6 bring.mogrify.merge_folders \u00b6 MergeFoldersMogrifier Objects \u00b6 class MergeFoldersMogrifier ( SimpleMogrifier ) Merge multiple folders into a single one, using one of the available merge strategies. This mogrifier is used internally, and, for now, can't be used in user-created mogrifier lists. bring.mogrify.rename \u00b6 bring.mogrify.git_archive \u00b6 bring.mogrify.archive \u00b6 ArchiveMogrifier Objects \u00b6 class ArchiveMogrifier ( ExtractMogrifier ) Alias for 'extract', check that mogrifiers documentation for details. bring.mogrify.download \u00b6 bring.mogrify.download_multiple_files \u00b6 bring.mogrify.folder \u00b6 bring.mogrify.helm_template \u00b6 bring.mogrify.file_filter \u00b6 FileFilterMogrifier Objects \u00b6 class FileFilterMogrifier ( SimpleMogrifier ) Filters files in a folder using glob patterns. Examples : binaries.hugo kubernetes.ingress-nginx bring.mogrify.extract \u00b6 ExtractMogrifier Objects \u00b6 class ExtractMogrifier ( SimpleMogrifier ) Extract an archive. This mogrifier is used internally, and, for now, can't be used in user-created mogrifier lists. Supported archive formats: - zip - tar - gztar - bztar - xztar bring.mogrify.git_clone \u00b6 bring.mogrify.install \u00b6 bring.mogrify.pick_subfolder \u00b6 bring.mogrify.move_to_subfolder \u00b6 bring.mogrify.merge_into \u00b6 bring.mogrify.dict_patch \u00b6 bring.mogrify.file \u00b6 FileMogrifier Objects \u00b6 class FileMogrifier ( SimpleMogrifier ) Alias for 'create_folder_from_file', check this mogrifiers documentation for details. bring.mogrify.flatten \u00b6","title":"Api documentation"},{"location":"api-documentation/#bring","text":"","title":"bring"},{"location":"api-documentation/#log","text":"Top-level package for bring.","title":"log"},{"location":"api-documentation/#bringutils","text":"","title":"bring.utils"},{"location":"api-documentation/#find_version","text":"find_version ( vars : Mapping [ str , str ], metadata : PkgMetadata , var_aliases_replaced = False ) -> Optional [ PkgVersion ] Return details about one version item of a package, using the provided vars to find one (or the first) version that matches most/all of the provided vars. Arguments : vars : User provided vars metadata : the package metadata","title":"find_version"},{"location":"api-documentation/#bringutilsgithub","text":"","title":"bring.utils.github"},{"location":"api-documentation/#bringutilsgit","text":"","title":"bring.utils.git"},{"location":"api-documentation/#bringutilsdefaults","text":"","title":"bring.utils.defaults"},{"location":"api-documentation/#bringutilsindexes","text":"","title":"bring.utils.indexes"},{"location":"api-documentation/#bringutilspkgs","text":"","title":"bring.utils.pkgs"},{"location":"api-documentation/#bringutilspkg_spec","text":"","title":"bring.utils.pkg_spec"},{"location":"api-documentation/#bringutilspaths","text":"","title":"bring.utils.paths"},{"location":"api-documentation/#bringutilssystem_info","text":"","title":"bring.utils.system_info"},{"location":"api-documentation/#bringutilsargs","text":"","title":"bring.utils.args"},{"location":"api-documentation/#bringutilsdoc","text":"","title":"bring.utils.doc"},{"location":"api-documentation/#bringutilsgitlab","text":"","title":"bring.utils.gitlab"},{"location":"api-documentation/#bringbring","text":"Main module.","title":"bring.bring"},{"location":"api-documentation/#bring-objects","text":"class Bring ( SimpleTing )","title":"Bring Objects"},{"location":"api-documentation/#get_pkg_map","text":"| async get_pkg_map ( * indexes ) -> Mapping [ str , Mapping [ str , PkgTing ]] Get all pkgs, per available (or requested) indexes.","title":"get_pkg_map"},{"location":"api-documentation/#get_full_package_name","text":"| async get_full_package_name ( package_name : str ) -> Optional [ str ] Get the full package name of a provided string. Mainly this is used to make sure there is an 'index-components' to a package name. The default index will be used if none was present. If the string is not a valid package name can't otherwise not be processed 'None' is returned.","title":"get_full_package_name"},{"location":"api-documentation/#bringdefaults","text":"","title":"bring.defaults"},{"location":"api-documentation/#bringpkg_index","text":"","title":"bring.pkg_index"},{"location":"api-documentation/#bringpkg_indexgitservice_user_index","text":"","title":"bring.pkg_index.gitservice_user_index"},{"location":"api-documentation/#bringpkg_indexfolder_index","text":"","title":"bring.pkg_index.folder_index"},{"location":"api-documentation/#bringpkg_indexstatic_index","text":"","title":"bring.pkg_index.static_index"},{"location":"api-documentation/#bringpkg_indexutils","text":"","title":"bring.pkg_index.utils"},{"location":"api-documentation/#diff_packages","text":"async diff_packages ( index_orig : BringIndexTing , index_new : BringIndexTing ) -> Mapping [ str , Any ] Diffs the packages of two indexes. This does not update any of the indexes, if that is the desired behaviour, do that beforehand.","title":"diff_packages"},{"location":"api-documentation/#bringpkg_indexconfig","text":"","title":"bring.pkg_index.config"},{"location":"api-documentation/#bringpkg_indexindex","text":"","title":"bring.pkg_index.index"},{"location":"api-documentation/#bringindexting-objects","text":"class BringIndexTing ( InheriTing , SimpleTing )","title":"BringIndexTing Objects"},{"location":"api-documentation/#update","text":"| async update ( in_background : bool = False ) -> None Updates pkg metadata.","title":"update"},{"location":"api-documentation/#bringpkg_indexfactory","text":"","title":"bring.pkg_index.factory"},{"location":"api-documentation/#bringpkg_indexpkgs","text":"","title":"bring.pkg_index.pkgs"},{"location":"api-documentation/#bringpkg_indexgitlab_user_index","text":"","title":"bring.pkg_index.gitlab_user_index"},{"location":"api-documentation/#bringpkg_indexgithub_user_index","text":"","title":"bring.pkg_index.github_user_index"},{"location":"api-documentation/#bring_meta","text":"","title":"bring._meta"},{"location":"api-documentation/#bringinterfaces","text":"","title":"bring.interfaces"},{"location":"api-documentation/#bringinterfacescli","text":"","title":"bring.interfaces.cli"},{"location":"api-documentation/#bringinterfacescliprocess","text":"","title":"bring.interfaces.cli.process"},{"location":"api-documentation/#bringinterfacesclilist_pkgs","text":"","title":"bring.interfaces.cli.list_pkgs"},{"location":"api-documentation/#bringlistpkgsgroup-objects","text":"class BringListPkgsGroup ( FrklBaseCommand )","title":"BringListPkgsGroup Objects"},{"location":"api-documentation/#format_commands","text":"| format_commands ( ctx , formatter ) Extra format methods for multi methods that adds all the commands after the options.","title":"format_commands"},{"location":"api-documentation/#bringinterfacescliutils","text":"","title":"bring.interfaces.cli.utils"},{"location":"api-documentation/#create_pkg_list_for_help","text":"async create_pkg_list_for_help ( bring : Bring , indicate_optional_index : bool = True ) -> List [ Tuple [ str , str ]] Extra format methods for multi methods that adds all the commands after the options.","title":"create_pkg_list_for_help"},{"location":"api-documentation/#bringinterfacescliconfig","text":"","title":"bring.interfaces.cli.config"},{"location":"api-documentation/#bringcontextgroup-objects","text":"class BringContextGroup ( FrklBaseCommand )","title":"BringContextGroup Objects"},{"location":"api-documentation/#__init__","text":"| __init__ ( bring_config : BringConfig , name : str = None , ** kwargs ) Install","title":"__init__"},{"location":"api-documentation/#bringcontextcommands-objects","text":"class BringContextCommands ( FrklBaseCommand )","title":"BringContextCommands Objects"},{"location":"api-documentation/#__init___1","text":"| __init__ ( bring_config : BringConfig , bring_context : ConfigTing , name : str = None , ** kwargs ) Install","title":"__init__"},{"location":"api-documentation/#bringinterfacesclidiffer","text":"","title":"bring.interfaces.cli.differ"},{"location":"api-documentation/#dev","text":"@click . group () @click . pass_context dev ( ctx ) Helper tasks for development.","title":"dev"},{"location":"api-documentation/#differ","text":"@dev . command () @click . argument ( \"path\" , nargs = 1 ) @click . pass_context async differ ( ctx , path ) Clear the bring cache dir in the relevant locaiont (e.g. '~/.cache/bring' on Linux).","title":"differ"},{"location":"api-documentation/#bringinterfacesclicli","text":"","title":"bring.interfaces.cli.cli"},{"location":"api-documentation/#bringinterfacescliplugin","text":"","title":"bring.interfaces.cli.plugin"},{"location":"api-documentation/#plugin","text":"@click . command () @click . pass_context @handle_exc_async async plugin ( ctx ) Clear the bring cache dir in the relevant locaiont (e.g. '~/.cache/bring' on Linux).","title":"plugin"},{"location":"api-documentation/#bringinterfacesclidev","text":"","title":"bring.interfaces.cli.dev"},{"location":"api-documentation/#bringdevgroup-objects","text":"class BringDevGroup ( FrklBaseCommand )","title":"BringDevGroup Objects"},{"location":"api-documentation/#__init___2","text":"| __init__ ( bring : Bring , name : str = None , ** kwargs ) Install","title":"__init__"},{"location":"api-documentation/#bringinterfacesclicommand_group","text":"","title":"bring.interfaces.cli.command_group"},{"location":"api-documentation/#bringinterfacesclicommands","text":"","title":"bring.interfaces.cli.commands"},{"location":"api-documentation/#bringinterfacesclicommandsexport_index","text":"","title":"bring.interfaces.cli.commands.export_index"},{"location":"api-documentation/#bringinterfacesclicommandsexplain","text":"","title":"bring.interfaces.cli.commands.explain"},{"location":"api-documentation/#bringinterfacesclicommandsinstall","text":"","title":"bring.interfaces.cli.commands.install"},{"location":"api-documentation/#bringinstallgroup-objects","text":"class BringInstallGroup ( FrklBaseCommand )","title":"BringInstallGroup Objects"},{"location":"api-documentation/#__init___3","text":"| __init__ ( bring : Bring , name : str = None , ** kwargs ) Install","title":"__init__"},{"location":"api-documentation/#format_commands_1","text":"| format_commands ( ctx , formatter ) Extra format methods for multi methods that adds all the commands after the options.","title":"format_commands"},{"location":"api-documentation/#bringinterfacesclicommandsupdate","text":"","title":"bring.interfaces.cli.commands.update"},{"location":"api-documentation/#bringinterfacesclicommandscreate","text":"","title":"bring.interfaces.cli.commands.create"},{"location":"api-documentation/#bringcreategroup-objects","text":"class BringCreateGroup ( FrklBaseCommand )","title":"BringCreateGroup Objects"},{"location":"api-documentation/#__init___4","text":"| __init__ ( name : str = None , ** kwargs ) Command to create bring-related elements.","title":"__init__"},{"location":"api-documentation/#bringcreatepkgdescgroup-objects","text":"class BringCreatePkgDescGroup ( FrklBaseCommand )","title":"BringCreatePkgDescGroup Objects"},{"location":"api-documentation/#__init___5","text":"| __init__ ( name : str = None , ** kwargs ) Command to create bring-related elements.","title":"__init__"},{"location":"api-documentation/#bringinterfacesclicommandsdoc","text":"","title":"bring.interfaces.cli.commands.doc"},{"location":"api-documentation/#bringdocgroup-objects","text":"class BringDocGroup ( FrklBaseCommand )","title":"BringDocGroup Objects"},{"location":"api-documentation/#__init___6","text":"| __init__ ( freckles : Freckles , name : str = \"doc\" , ** kwargs ) Install","title":"__init__"},{"location":"api-documentation/#bringfrecklets","text":"","title":"bring.frecklets"},{"location":"api-documentation/#bringfreckletstemplate","text":"","title":"bring.frecklets.template"},{"location":"api-documentation/#bringfreckletsinstall_pkg","text":"","title":"bring.frecklets.install_pkg"},{"location":"api-documentation/#bringfreckletsinstall_pkgtasks","text":"","title":"bring.frecklets.install_pkg.tasks"},{"location":"api-documentation/#bringfreckletsinstall_pkgfrecklet","text":"","title":"bring.frecklets.install_pkg.frecklet"},{"location":"api-documentation/#bringfreckletsinstall_assembly","text":"","title":"bring.frecklets.install_assembly"},{"location":"api-documentation/#bringfreckletsinstall_assemblyassembly","text":"","title":"bring.frecklets.install_assembly.assembly"},{"location":"api-documentation/#bringfreckletsinstall_assemblytasks","text":"","title":"bring.frecklets.install_assembly.tasks"},{"location":"api-documentation/#bringfreckletsinstall_assemblyfrecklet","text":"","title":"bring.frecklets.install_assembly.frecklet"},{"location":"api-documentation/#bringplugins","text":"","title":"bring.plugins"},{"location":"api-documentation/#bringpluginstemplating","text":"","title":"bring.plugins.templating"},{"location":"api-documentation/#bringpluginstemplatingcli","text":"","title":"bring.plugins.templating.cli"},{"location":"api-documentation/#bringpluginstemplatingcore","text":"","title":"bring.plugins.templating.core"},{"location":"api-documentation/#bringconfig","text":"","title":"bring.config"},{"location":"api-documentation/#configting-objects","text":"class ConfigTing ( InheriTing , SimpleTing ) Represents a config profile. Config profiles can inherit from other profiles, overwriting one or several of the parent key/value pairs.","title":"ConfigTing Objects"},{"location":"api-documentation/#bringconfigfolder_config","text":"","title":"bring.config.folder_config"},{"location":"api-documentation/#folderconfigprofilesting-objects","text":"class FolderConfigProfilesTing ( SimpleTing )","title":"FolderConfigProfilesTing Objects"},{"location":"api-documentation/#__init___7","text":"| __init__ ( name : str , meta : TingMeta , config_path : str , config_file_ext : str = \"config\" ) A class to hold a set of ConfigTings, and gives access to them and their config dicts.","title":"__init__"},{"location":"api-documentation/#get_contexts","text":"| async get_contexts ( update : bool = False ) -> Mapping [ str , ConfigTing ] Get all available config profiles.","title":"get_contexts"},{"location":"api-documentation/#get_config_dicts","text":"| async get_config_dicts ( update : bool = False ) -> Mapping [ str , Mapping [ str , Any ]] Retrun the values of all available config profiles.","title":"get_config_dicts"},{"location":"api-documentation/#bringconfigbring_config","text":"","title":"bring.config.bring_config"},{"location":"api-documentation/#bringconfig-objects","text":"class BringConfig ( object ) Wrapper to manage and access the configuration of a Bring instance.","title":"BringConfig Objects"},{"location":"api-documentation/#bringpkg_types","text":"","title":"bring.pkg_types"},{"location":"api-documentation/#pkgtype-objects","text":"class PkgType (, metaclass = ABCMeta ) Abstract base class which acts as an adapter to retrieve package information using the 'source' key in bring pkg metadata.","title":"PkgType Objects"},{"location":"api-documentation/#__init___8","text":"| __init__ ( arg_hive : ArgHive , ** config : Any ) The base class to inherit from to create package metadata of a certain type. Supported config keys (so far): metadata_max_age : age of metadata in seconds that is condsidered valid (set to 0 to always invalidate/re-load metadata, -1 to never invalidate)","title":"__init__"},{"location":"api-documentation/#get_args","text":"| @abstractmethod | get_args () -> Mapping [ str , Mapping [ str , Any ]] A dictionary describing which arguments are necessary to create a package of this type.","title":"get_args"},{"location":"api-documentation/#get_unique_source_id","text":"| get_unique_source_id ( source_details : Mapping [ str , Any ]) -> str Return a calculated unique id for a package. Implement your own '_get_unique_type_source_id' method for a type specific, meaningful id. If that method is not overwritten, a 'deephash' of the source dictionary is used. This is used mainly for caching purposes.","title":"get_unique_source_id"},{"location":"api-documentation/#get_seed_data","text":"| async get_seed_data ( source_details : Mapping [ str , Any ]) Overwrite to provide seed data for a pkg. This is mostly used for the 'bring-pkg' type, in order to retrieve parent metadata. Currently only 'info' and 'labels' keys are supported.","title":"get_seed_data"},{"location":"api-documentation/#get_pkg_metadata","text":"| async get_pkg_metadata ( source_details : Union [ str , Mapping [ str , Any ]], override_config : Optional [ Mapping [ str , Any ]] = None ) -> PkgMetadata Return metadata of a bring package, specified via the provided source details and current index. If a string is provided as 'source_details', it'll be converted into a dict like: {\"url\": <source_details>} . Arguments : source_details - the pkg-type specific details that are needed to create the package metadata override_config - optional configuration to adjust pkg metadata creation (e.g. cache invalidation, etc). overrides the default pkg-type config. Returns : PkgMetadata - the package metadata","title":"get_pkg_metadata"},{"location":"api-documentation/#process_vars","text":"| async process_vars ( source_args : Mapping [ str , Any ], pkg_args : Mapping [ str , Any ], mogrifiers : Union [ Iterable , Mapping ], source_vars : Mapping [ str , Any ], versions : List [ PkgVersion ], aliases : Mapping [ str , Mapping [ str , str ]]) -> Mapping [ str , Any ] Return the (remaining) args a user can specify to select a version or mogrify options.","title":"process_vars"},{"location":"api-documentation/#_1","text":"Source args can contain more arguments than will eventually be used/displayed to the user. Arguments : source_args : dictionary of args to describe the type/schema of an argument pkg_args : a dictionary of automatically created args by a specific resolver. Those will be used as base, but will be overwritten by anything in 'source_args' mogrifiers : the 'mogrify' section of the pkg 'source' source_vars : vars that are hardcoded in the 'source' section of a package, can also contain templates versions : all avaailable versions of a package aliases : a dictionary of value aliases that can be used by the user instead of the 'real' ones. Aliases are per arg name. Returns : a dictionary with 3 keys: args, version_vars, mogrify_vars","title":""},{"location":"api-documentation/#bringpkg_typesgit_files","text":"","title":"bring.pkg_types.git_files"},{"location":"api-documentation/#gitfiles-objects","text":"class GitFiles ( PkgType ) A package type to retrieve one or several files from a git repository. Under the hood, this uses the git archive command to retrieve a zipped archive of the requested files, so when specifying the git url, make sure to either use the git or ssh protocol, or, if using https , that the remote server supports Smart HTTP (GitHub, for example, does not as far as I know). To filter out certain tags you don't want to end up as 'version's, you can use the tag_filter key, and specify a regular explression of 'allowed' tags. Templated file paths are not supported currently, but will be in the future. examples: - gitlab.bring-indexes.example-index.bring_readme","title":"GitFiles Objects"},{"location":"api-documentation/#bringpkg_typesgit_repo","text":"","title":"bring.pkg_types.git_repo"},{"location":"api-documentation/#gitrepo-objects","text":"class GitRepo ( PkgType ) A package that represents a git repository and its content. The only argument required is the git repository url. bring will download and cache (unless otherwise configured) the whole repo. Depending on the repository size this might or might not be desirable. If the repository is large, and only one or a few files are wanted, it is probably better to use the git_files (or github_files , gitlab_files , ...) package type, as this only downloads the files needed. If one git repository is the shared source for multiple packages, this package type might be the better choice though, since it will be only downloaded and cached once, and retrieval of each of those packages is quicker (since the git repository is cached locally, and only a git checkout is necessary to retrieve a specific version). By default, all tags and branches will be used as version names. If ' use_commits_as_versions ' is set to ' true ', also the commit hashes will be used. An alias ' latest ' will be added, pointing to the latest tag, or, in case no tags exist, to the 'master' branch. Examples : scripts.bashtop","title":"GitRepo Objects"},{"location":"api-documentation/#bringpkg_typesfolder","text":"","title":"bring.pkg_types.folder"},{"location":"api-documentation/#folder-objects","text":"class Folder ( PkgType ) A package type to represent a local folder. This is mostly used in local development, documentation still to be done...","title":"Folder Objects"},{"location":"api-documentation/#bringpkg_typesgitlab_files","text":"","title":"bring.pkg_types.gitlab_files"},{"location":"api-documentation/#gitfiles-objects_1","text":"class GitFiles ( PkgType ) A package type to retrieve one or several files from a git repository that is hosted on GitLab . This package type directly downloads the required files from GitLab, without retrieving the repository itself first. This way of accessing files is advantageous if you only need a few, small files, and the repository itself is on the larger side. If this is not the case, consider using the ' git_repo ' package type. File-paths specified in the files argument can contain template place-holders (like: deploy/${provider}/config.json ). If that is the case, you need to provide a list of possible values for each of the included placeholders in the template_values key (check the example below). examples: - gitlab.bring-indexes.example-index.example_file1","title":"GitFiles Objects"},{"location":"api-documentation/#bringpkg_typesgithub_release","text":"","title":"bring.pkg_types.github_release"},{"location":"api-documentation/#githubrelease-objects","text":"class GithubRelease ( PkgType ) A package type that tracks GitHub release artefacts. To be able to get a list of all releases and their metadata, a package needs to specify the github user- and repo-names, as well as a regex to parse the release urls and compute the variables (version, architecture, os, etc.) involved to assemble a list of versions for a package. This is a barebones example for a source definition for the fd application: source : type : github-release user_name : sharkdp repo_name : fd url_regex : 'https://github.com/.*/releases/download/v(?P<version>.*)/.*-v(?P=version)-(?P<arch>[^-]*)-(?P<os>[^.]*)\\\\..*$' More than one such regular expressions can be provided (in which case the value for url_regex should be a list), all matches for all regexes will be added to the resulting list. Most of the regexes for different packages look fairly similar, but unfortunately Github release-urls don't follow a standard, which makes it impossible to come up with one that can be used for all of them. bring comes with a default regex that works for quite a few Github projects (and almost for a lot of others). In fact, the regex in the example above is the default regex that will be used if no ' url_regex ' value is provided, and it so happens that it works for ' fd ' (which means we could have omitted it for that particular application). Nonetheless, whoever creates a new package manifest needs to manually verify whether the default regex works, and then adjust or create a totally different one if necessary. examples: - binaries.k3d - kubernetes.cert-manager","title":"GithubRelease Objects"},{"location":"api-documentation/#bringpkg_typesgithub_files","text":"","title":"bring.pkg_types.github_files"},{"location":"api-documentation/#gitfiles-objects_2","text":"class GitFiles ( PkgType ) A package type to retrieve one or several files from a git repository that is hosted on GitHub . This package type directly downloads the required files from GitHub, without downloading the repository itself first. This way of accessing files is advantageous if you only need a few, small files, and the repository itself is on the larger side. If this is not the case, consider using the ' git_repo ' package type. File-paths specified in the files argument can contain template place-holders (like: deploy/${provider}/config.json ). If that is the case, you need to provide a list of possible values for each of the included placeholders in the template_values key (check the example below). examples: - kubernetes.ingress-nginx","title":"GitFiles Objects"},{"location":"api-documentation/#bringpkg_typestemplate_url","text":"","title":"bring.pkg_types.template_url"},{"location":"api-documentation/#templateurlresolver-objects","text":"class TemplateUrlResolver ( PkgType ) A package type to resolve packages whose artifacts are published with static urls that can be templated. All values of all template variables are combined with each of the other template variables to create a matrix of possible combinations. In some cases some of those combinations are not valid, and lead to a url that does not resolve to a file to download. At this time, there is nothing that can be done about it and the user will see an error message. Examples : binaries.kubectl binaries.helm","title":"TemplateUrlResolver Objects"},{"location":"api-documentation/#bringdoc","text":"","title":"bring.doc"},{"location":"api-documentation/#bringdocindex","text":"","title":"bring.doc.index"},{"location":"api-documentation/#bringdocplugins","text":"","title":"bring.doc.plugins"},{"location":"api-documentation/#bringdocargs","text":"","title":"bring.doc.args"},{"location":"api-documentation/#bringdocpkg","text":"","title":"bring.doc.pkg"},{"location":"api-documentation/#bringpkg","text":"","title":"bring.pkg"},{"location":"api-documentation/#pkgting-objects","text":"class PkgTing ( SimpleTing )","title":"PkgTing Objects"},{"location":"api-documentation/#get_metadata","text":"| @abstractmethod | async get_metadata ( config : Optional [ Mapping [ str , Any ]] = None , register_task : bool = False ) -> PkgMetadata Return metadata associated with this package.","title":"get_metadata"},{"location":"api-documentation/#dynamicpkgting-objects","text":"class DynamicPkgTing ( PkgTing )","title":"DynamicPkgTing Objects"},{"location":"api-documentation/#get_metadata_1","text":"| async get_metadata ( config : Optional [ Mapping [ str , Any ]] = None , register_task : bool = False ) -> PkgMetadata Return metadata associated with this package.","title":"get_metadata"},{"location":"api-documentation/#bringmogrify","text":"","title":"bring.mogrify"},{"location":"api-documentation/#mogrifier-objects","text":"class Mogrifier ( Task , SimpleTing ) The base class to extend to implement a 'Mogrifier'. A mogrifier is one part of a pipeline, usually taking an input folder, along other arguments, and providing an output folder path as result. Which in turn is used by the subsequent Mogrifier as input, etc. There are a few special cases, for example the 'download' mogrifier which takes a url as input and provides a path to a file (not folder) as output, or the 'extract' mogrifier which takes an (archive) file as input and provides a folder path as output. Currently there is not much checking whether Mogrifiers that are put together fit each others input/output arguments, but that will be implemented at some stage. So, for now, it's the users responsibility to assemble mogrifier pipelines that make sense. An implementation of a Mogrifier can either provide class-level attributes '_provides' and '_requires', or implement the 'provides()' and 'requires()' instance or class level methods. This method will be only read once per Ting prototype (TODO: reference), so make sure to not process any calculated values in there.","title":"Mogrifier Objects"},{"location":"api-documentation/#transmogritory-objects","text":"class Transmogritory ( SimpleTing ) Registry that holds all mogrify plugins.","title":"Transmogritory Objects"},{"location":"api-documentation/#bringmogrifytemplate","text":"","title":"bring.mogrify.template"},{"location":"api-documentation/#bringmogrifytransform_folder","text":"","title":"bring.mogrify.transform_folder"},{"location":"api-documentation/#foldercontentmogrifier-objects","text":"class FolderContentMogrifier ( SimpleMogrifier ) Merge multiple folders into a single one, using one of the available merge strategies. This mogrifier is used internally, and, for now, can't be used in user-created mogrifier lists.","title":"FolderContentMogrifier Objects"},{"location":"api-documentation/#bringmogrifyparallel_pkg_merge","text":"","title":"bring.mogrify.parallel_pkg_merge"},{"location":"api-documentation/#bringmogrifyset_mode","text":"","title":"bring.mogrify.set_mode"},{"location":"api-documentation/#bringmogrifymerge_folders","text":"","title":"bring.mogrify.merge_folders"},{"location":"api-documentation/#mergefoldersmogrifier-objects","text":"class MergeFoldersMogrifier ( SimpleMogrifier ) Merge multiple folders into a single one, using one of the available merge strategies. This mogrifier is used internally, and, for now, can't be used in user-created mogrifier lists.","title":"MergeFoldersMogrifier Objects"},{"location":"api-documentation/#bringmogrifyrename","text":"","title":"bring.mogrify.rename"},{"location":"api-documentation/#bringmogrifygit_archive","text":"","title":"bring.mogrify.git_archive"},{"location":"api-documentation/#bringmogrifyarchive","text":"","title":"bring.mogrify.archive"},{"location":"api-documentation/#archivemogrifier-objects","text":"class ArchiveMogrifier ( ExtractMogrifier ) Alias for 'extract', check that mogrifiers documentation for details.","title":"ArchiveMogrifier Objects"},{"location":"api-documentation/#bringmogrifydownload","text":"","title":"bring.mogrify.download"},{"location":"api-documentation/#bringmogrifydownload_multiple_files","text":"","title":"bring.mogrify.download_multiple_files"},{"location":"api-documentation/#bringmogrifyfolder","text":"","title":"bring.mogrify.folder"},{"location":"api-documentation/#bringmogrifyhelm_template","text":"","title":"bring.mogrify.helm_template"},{"location":"api-documentation/#bringmogrifyfile_filter","text":"","title":"bring.mogrify.file_filter"},{"location":"api-documentation/#filefiltermogrifier-objects","text":"class FileFilterMogrifier ( SimpleMogrifier ) Filters files in a folder using glob patterns. Examples : binaries.hugo kubernetes.ingress-nginx","title":"FileFilterMogrifier Objects"},{"location":"api-documentation/#bringmogrifyextract","text":"","title":"bring.mogrify.extract"},{"location":"api-documentation/#extractmogrifier-objects","text":"class ExtractMogrifier ( SimpleMogrifier ) Extract an archive. This mogrifier is used internally, and, for now, can't be used in user-created mogrifier lists. Supported archive formats: - zip - tar - gztar - bztar - xztar","title":"ExtractMogrifier Objects"},{"location":"api-documentation/#bringmogrifygit_clone","text":"","title":"bring.mogrify.git_clone"},{"location":"api-documentation/#bringmogrifyinstall","text":"","title":"bring.mogrify.install"},{"location":"api-documentation/#bringmogrifypick_subfolder","text":"","title":"bring.mogrify.pick_subfolder"},{"location":"api-documentation/#bringmogrifymove_to_subfolder","text":"","title":"bring.mogrify.move_to_subfolder"},{"location":"api-documentation/#bringmogrifymerge_into","text":"","title":"bring.mogrify.merge_into"},{"location":"api-documentation/#bringmogrifydict_patch","text":"","title":"bring.mogrify.dict_patch"},{"location":"api-documentation/#bringmogrifyfile","text":"","title":"bring.mogrify.file"},{"location":"api-documentation/#filemogrifier-objects","text":"class FileMogrifier ( SimpleMogrifier ) Alias for 'create_folder_from_file', check this mogrifiers documentation for details.","title":"FileMogrifier Objects"},{"location":"api-documentation/#bringmogrifyflatten","text":"","title":"bring.mogrify.flatten"},{"location":"documentation/getting-help/","text":"The bring command-line interface is designed to be (mostly) self explanatory. Use the --help option to see available sub-commands and their options and general usage instructions. > bring --help Usage: bring [OPTIONS] COMMAND [ARGS]... 'bring' is a package manager for files and file-sets. 'bring'-managed files that are part of so called 'indexes': collections of metadata items, each describing one specific file or file-set. Options: -o, --output TEXT which output plugins to use, defaults to 'terminal' -i, --index TEXT one or several profile index(s), overwrites indexes in configuration -c, --config TEXT configuration option(s) and/or profile name(s) -h, --help Show this message and exit. Commands: install install one or a list of packages explain display context, index, pkg, or target information list list packages for all registered indexes update update index metadata export-index export index folder metadata to file create create bring-related elementes doc documentation for application components self utilites to manage/display info about this application","title":"Getting help"},{"location":"documentation/indexes/","text":"Indexes \u00b6 Definition \u00b6 A bring index is a collection of packages . Each index has a (namespaced) unique name (e.g. gitlab.bring-indexes.binaries ); some of the indexes that ship with bring are non-namespaced aliases for a fully-namespaced index names ( binaries , in this case). Each package in a bring index is referred to by a unique (within that index) name. That package name can't contain '.'-characters. That means, bring can resolve every namespaced string like gitlab.bring-indexes.binaries.fd (or its alias binaries.fd ) into a globally unique bring package. Creating an index \u00b6 There are different ways to create an index, but the main one is to just have a folder (in most cases: a remote git repository) containing bring package description files. Those files are basically text files with a .pkg.br -extension, containing a YAML document. Check the binary index to see how such a directory could look like: https://gitlab.com/bring-indexes/binaries Packages names are derived from the description file name (without the .pkg.br extension), and an index should never contain the same package name more than once (even if they are located in different subfolders), as that can lead to errors or unpredictable outcomes. Exporting index data \u00b6 As parsing a local or remote folder structure can become slow once such a folder contains a lot of files, it is also possible to 'export' all the package data contained in an index into a single index file. The command for that is: > bring export-index [path-to-index-folder] No previous index file exists, writing new one... Exporting index to file: /home/runner/work/bring/bring/docs/examples/.bring/ this.idx.br This will create a file [path-to-index-folder]/.bring/this.idx.br , which is a gzipped json file with a snapshot of all the resolved package data of this index. If such a file exists, bring will use that instead of parsing a folder/repository. In addition to not having to parse a folder structure anymore, this also makes package version lookups faster, since all the version information is 'frozen' within such an index file. The one disadvantage is that package data is more likely to be out of date than a 'freshly' parsed index folder. This is not always the case though, since bring also caches package version information locally, after the first lookup, which means that issuing a bring update every now and then is advisable. TODO: explain consistency check/index updates","title":"Indexes"},{"location":"documentation/indexes/#indexes","text":"","title":"Indexes"},{"location":"documentation/indexes/#definition","text":"A bring index is a collection of packages . Each index has a (namespaced) unique name (e.g. gitlab.bring-indexes.binaries ); some of the indexes that ship with bring are non-namespaced aliases for a fully-namespaced index names ( binaries , in this case). Each package in a bring index is referred to by a unique (within that index) name. That package name can't contain '.'-characters. That means, bring can resolve every namespaced string like gitlab.bring-indexes.binaries.fd (or its alias binaries.fd ) into a globally unique bring package.","title":"Definition"},{"location":"documentation/indexes/#creating-an-index","text":"There are different ways to create an index, but the main one is to just have a folder (in most cases: a remote git repository) containing bring package description files. Those files are basically text files with a .pkg.br -extension, containing a YAML document. Check the binary index to see how such a directory could look like: https://gitlab.com/bring-indexes/binaries Packages names are derived from the description file name (without the .pkg.br extension), and an index should never contain the same package name more than once (even if they are located in different subfolders), as that can lead to errors or unpredictable outcomes.","title":"Creating an index"},{"location":"documentation/indexes/#exporting-index-data","text":"As parsing a local or remote folder structure can become slow once such a folder contains a lot of files, it is also possible to 'export' all the package data contained in an index into a single index file. The command for that is: > bring export-index [path-to-index-folder] No previous index file exists, writing new one... Exporting index to file: /home/runner/work/bring/bring/docs/examples/.bring/ this.idx.br This will create a file [path-to-index-folder]/.bring/this.idx.br , which is a gzipped json file with a snapshot of all the resolved package data of this index. If such a file exists, bring will use that instead of parsing a folder/repository. In addition to not having to parse a folder structure anymore, this also makes package version lookups faster, since all the version information is 'frozen' within such an index file. The one disadvantage is that package data is more likely to be out of date than a 'freshly' parsed index folder. This is not always the case though, since bring also caches package version information locally, after the first lookup, which means that issuing a bring update every now and then is advisable. TODO: explain consistency check/index updates","title":"Exporting index data"},{"location":"documentation/install/","text":"Installation \u00b6 There are three ways to install bring on your machine. Via a manual binary download, an install script, or installation of the python package. Binaries \u00b6 To install bring , download the appropriate binary from one of the links below, and set the downloaded file to be executable ( chmod +x bring ): Linux Mac OS X (not tested much) Windows (not tested at all) Note : Currently, only development versions are available. Install script \u00b6 Alternatively, use the 'curly' install script for bring : curl https://bring.sh | bash This will add a section to your shell init file to add the install location ( $HOME/.local/share/frkl/bin ) to your $PATH . You might need to source that file (or log out and re-log in to your session) in order to be able to use bring : source ~/.profile Python package \u00b6 The python package is currently not available on pypi , so you need to specify the --extra-url parameter for your pip command. If you chooose this install method, I assume you know how to install Python packages manually, which is why I only show you an example way of getting bring onto your machine: > python3 -m venv ~/.venvs/bring > source ~/.venvs/bring/bin/activate > pip install --extra-index-url https://pkgs.frkl.io/frkl/dev bring Looking in indexes: https://pypi.org/simple, https://pkgs.frkl.io/frkl/dev Collecting bring Downloading http://pkgs.frkl.io/frkl/dev/%2Bf/ee3/f57bd91a076f9/bring-0.1.dev24%2Bgd3c4447-py2.py3-none-any.whl (28 kB) ... ... ... Successfully installed aiokafka-0.6.0 aiopg-1.0.0 ... ... ... > bring --help Usage: bring [OPTIONS] COMMAND [ARGS]... ... ...","title":"Installation"},{"location":"documentation/install/#installation","text":"There are three ways to install bring on your machine. Via a manual binary download, an install script, or installation of the python package.","title":"Installation"},{"location":"documentation/install/#binaries","text":"To install bring , download the appropriate binary from one of the links below, and set the downloaded file to be executable ( chmod +x bring ): Linux Mac OS X (not tested much) Windows (not tested at all) Note : Currently, only development versions are available.","title":"Binaries"},{"location":"documentation/install/#install-script","text":"Alternatively, use the 'curly' install script for bring : curl https://bring.sh | bash This will add a section to your shell init file to add the install location ( $HOME/.local/share/frkl/bin ) to your $PATH . You might need to source that file (or log out and re-log in to your session) in order to be able to use bring : source ~/.profile","title":"Install script"},{"location":"documentation/install/#python-package","text":"The python package is currently not available on pypi , so you need to specify the --extra-url parameter for your pip command. If you chooose this install method, I assume you know how to install Python packages manually, which is why I only show you an example way of getting bring onto your machine: > python3 -m venv ~/.venvs/bring > source ~/.venvs/bring/bin/activate > pip install --extra-index-url https://pkgs.frkl.io/frkl/dev bring Looking in indexes: https://pypi.org/simple, https://pkgs.frkl.io/frkl/dev Collecting bring Downloading http://pkgs.frkl.io/frkl/dev/%2Bf/ee3/f57bd91a076f9/bring-0.1.dev24%2Bgd3c4447-py2.py3-none-any.whl (28 kB) ... ... ... Successfully installed aiokafka-0.6.0 aiopg-1.0.0 ... ... ... > bring --help Usage: bring [OPTIONS] COMMAND [ARGS]... ... ...","title":"Python package"},{"location":"documentation/overview/","text":"Concepts \u00b6 The purpose of bring is to copy files and file-sets onto the local system, in a reliable, replicable way. The three main concepts to understand in regards to bring are: package A package is a specific file or file-set, usually versioned in some way (via git, releases, etc.). In most cases, a package is uniquely identified by an index name (see below) and the package name as the right-most part of the string: [index.name.space].[package_name] , e.g. gitlab.tingistries.binaries . indexes An index is a list that contains metadata for one or several packages , usually of one category (single-file binaries, templates, etc...) or otherwise belonging together. Indexes can be of different types, the most common ones will be pointing to git repositories on GitLab/GitHub/etc in the form of [service_name.user_name.repo_name] , e.g. gitlab.tingistries.binaries . In addition, the indexes that are included in bring usually have single-name aliases (e.g. binaries ). contexts Sets of indexes and other configuration values are managed within so-called contexts ; by default bring uses a pre-defined default context that comes with a set of indexes which are deemed of interest for a general audience. Like for example the binaries index, which lets you install single-file executables.","title":"Overview"},{"location":"documentation/overview/#concepts","text":"The purpose of bring is to copy files and file-sets onto the local system, in a reliable, replicable way. The three main concepts to understand in regards to bring are: package A package is a specific file or file-set, usually versioned in some way (via git, releases, etc.). In most cases, a package is uniquely identified by an index name (see below) and the package name as the right-most part of the string: [index.name.space].[package_name] , e.g. gitlab.tingistries.binaries . indexes An index is a list that contains metadata for one or several packages , usually of one category (single-file binaries, templates, etc...) or otherwise belonging together. Indexes can be of different types, the most common ones will be pointing to git repositories on GitLab/GitHub/etc in the form of [service_name.user_name.repo_name] , e.g. gitlab.tingistries.binaries . In addition, the indexes that are included in bring usually have single-name aliases (e.g. binaries ). contexts Sets of indexes and other configuration values are managed within so-called contexts ; by default bring uses a pre-defined default context that comes with a set of indexes which are deemed of interest for a general audience. Like for example the binaries index, which lets you install single-file executables.","title":"Concepts"},{"location":"documentation/configuration/overview/","text":"contexts : Sets of indexes are managed within so-called contexts ; by default bring uses a pre-defined default context that comes with a set of indexes which are deemed of interest for a general audience. Like for example the already mentioned binaries index, which contains single-file executables. Even though this is not covered in this quick-start guide it is easily possible to create and share your own indexes . Check out the usage documentation for more details. In fact, this is actually the main use-case for bring . But for the purpose of this quick start we will only concern ourselves with the default context, and it's default set of indexes . It pays to keep all that in mind though, as that will allow you to extrapolate other, more specific use-cases on your own.","title":"Overview"},{"location":"documentation/packages/overview/","text":"A package is the central object within bring . A package declaratively describes a set of files (or a single one), how to retrieve those files, and how to process them so that they end up in a predictable arrangement on a selected target, once installed.","title":"Overview"},{"location":"documentation/packages/package-description/","text":"A package description is composed of two parts: the package source (required) a data structure that describes where to retrieve the files of a package, and how to assemble them (e.g. whether to rename some files, make some of them executable, etc.) additional package metadata (optional) other, optional metadata (like the author/publisher of the file, a homepage, labels, tags...) Example \u00b6 To get an idea how a full, 'working' package description looks like, here's one that lets you install the pandoc binary, an application to convert between document formats: info : homepage : https://pandoc.org/ slug : Universal markup converter desc : | Pandoc is a Haskell library for converting from one markup format to another, and a command-line tool that uses this library. tags : - document-formats - convert - markdown labels : executable_type : binary language : haskell source : type : github_release user_name : jgm repo_name : pandoc url_regex : - https://github\\.com/jgm/pandoc/releases/download/(?P<version>.*)/pandoc-(?P=version)-(?P<os>[^-.]*)(-(?P<arch>[^-.]*))?(\\.tar\\.gz|\\.zip)$ aliases : arch : x86_64 : amd64 os : darwin : macOS artefact : type : archive transform : - bin/pandoc : mode : 755 path : pandoc You can use the explain subcommand to debug a package, and print out the data it collects: > bring explain pkg [path_to_pandoc_desc_file].pkg.br Package binaries.pandoc (Universal markup converter) desc Pandoc is a Haskell library for converting from one markup format to another, and a command-line tool that uses this library. homepage https://pandoc.org/ Variables arch The architecture the binary is built for. default -- no default -- required yes type string allowed amd64 (alias: x86_64) i386 os The operating system to run on. default -- no default -- required yes type string allowed 3 macOS (alias: darwin) linux osx windows version The version of the package. default latest required yes type string allowed 2.10.1 (aliases: stable, latest) 2.10 2.9.2.1 2.9.2 2.9.1.1 2.9.1 2.9 2.8.1 2.8.0.1 2.8 2.7.3 2.7.2 2.7.1 2.7 2.6 2.5 2.4 2.3.1 2.3 2.2.3.2 2.2.3.1 2.2.2.1 2.2.2 2.2.1 2.2 2.1.3 2.1.2 2.1.1 2.1 2.0.6 2.0.5 2.0.4 2.0.3 2.0.2 2.0.1.1 2.0.1 2.0.0.1 2.0 1.12.4.2 section: ' source ' \u00b6 A packacke description must have a section with the key source . Ideally, it describes a package in a way that is idempotent, which means that, if given the same input values, it'll always yield the exact same files, in the exact same folder structure. In some cases that is not possible/required, but we'll ignore that for now and assume idempotency. The source section itself can be split up into 3 different sub-sections: key: ' type ' \u00b6 The name of the package type plugin that will read and process this data. bring supports multiple such package types, to accomodate for the different ways people publish their files. Currently available, official package types are: git_files : a package type to retrieve one or several files from a git repository git_repo : a package that represents a git repository and its content github_files : a package type to retrieve one or several files from a git repository that is hosted on GitHub github_release : a package type that tracks GitHub release artefacts gitlab_files : a package type to retrieve one or several files from a git repository that is hosted on GitLab template_url : a package type to resolve packages whose artifacts are published with static urls that can be templated type-specific keys \u00b6 Each package type has different required and optional arguments. Check their respective documentation for details. common keys (optional) \u00b6 bring uses package-type plugins to retrieve source files for packages, but then uses the same code to post-process those files. This code also can take some input in order to costumize the final structure of a package. Those keys are currently supported: aliases \u00b6 A dictionary with the variable names as keys, and an alias dictionary (with alias as key, and final value as, well, ...value). E.g., for: os : linux : unknown-linux-gnu darwin : apple-darwin ...an input value of linux for the os variable would resolve to unknown-linux-gnu . Package types sometimes provider their own aliases (for example 'latest' as a pointer to the latest version of a github release). args \u00b6 A dictionary to let you control how package arguments are presented to the user. bring comes with default argument configurations for 3 argument keys: version , arch , os . If your package has other input variables (or if you want to override the defaults), you can do that here. Here is a list of available configuration keys (all of them optional): doc : a string describing the argument type : the type of the argument. supported: \"any\", \"string\", \"integer\", \"list\", \"dict\", \"boolean\" (and a few others, to be documented later -- defaults to \"any\") default : a default value if none is provided for the (no default) required : whether the argument is required or optional (defaults to 'true') multiple : whether a only a single, or multiple values are allowed (defaults to 'false') allowed : a list of allowed values (not implemented yet -- no default) As an example for the: the kubernetes.ingress requires an extra provider argument, to determine the exact yaml manifest file to select. This variable is described with data like: args : provider : doc : The provider to deploy to. default : cloud This will change the output of the package install help command to be: > bring install kubernetes.ingress-nginx --help Usage: bring install kubernetes.ingress-nginx [OPTIONS] Options: --provider PROVIDER The provider to deploy to. --version VERSION The version of the package. -h, --help Show this message and exit. And it will use cloud as value for that key if not specified otherwise by the user. artefact \u00b6 An optional hint to specify the type of source package artefact for a package (which could be a tar.gz- or zip-archive, a folder, a single-file, etc.). Internally, bring requires each package to be a folder containing one or several files. This argument helps transform single-file artefacts (archive, normal file) into a folder (for example by extracting it, or move a single downloaded file into a newly created temporary folder). In most cases, you won't need to specify it. For the cases where that is not true, those values are currently supported: file - a plain, single file folder - a folder (for example when the artefact is a git repository) archive - an archive file (currently supported archive types: zip, tar, tar.gz, tar.bz2, xtar) If artefact is not specified, a semi-smart detection mechanism is used (which should work for most cases). transform \u00b6 Optional configuration to control which files that are contained in the original artefact will end up in the package. This is the most used configuration option, as often you are not interested in supplementary files (licenses, configuration examples, etc.) to be installed into the target. Configuration for this value is done via providing a list of items as input. Each item can either be a string (for simple filtering), or a dictionary of values (if more advanced configuration is necessary). If no value for transform is provided, all files of the package will be copied into the target. If one or several list items are set, only those will be used, and all non-matching files will be ignored. If a list item is a string, the full path to that file is looked up in the source package folder, and copied over to the target using the exact same path/filename. If a dictionary is provided, those are the available configuration keys: from (required string): the path to the file/the filename in the source to (optional string): the target path/filename (defaults to the value of from ) mode (optional, string or integeer): the permissions of the file on the target (e.g. '0755', 644, ...) All variables that are used to resolve a version of a package are allowed in variable placeholders ( ${var_name} ). An full example from the binaries.k3d package, which renames an os-specificly named file to a more generic name, and also makes the file executable: transform : - path : k3d from : \"k3d-${ os }-amd64\" mode : 755 Other configuration keys are not supported currently, neither is selecting files via globs/regexs. There are plans to do that in the future though. Mixing string and dictionary items is allowed. metadata sections: \u00b6 section: ' info ' \u00b6 Contains information about the package itself, the most important sub-keys are: slug (description of the package), homepage . section: \" tags \" \u00b6 A list of strings containing tags that apply to the package. This is not used at the moment, but will be later to filter/select packages. section: \" labels \" \u00b6 A list of strings containing labels that apply to the package. This is not used at the moment, but will be later to filter/select packages.","title":"Package description"},{"location":"documentation/packages/package-description/#example","text":"To get an idea how a full, 'working' package description looks like, here's one that lets you install the pandoc binary, an application to convert between document formats: info : homepage : https://pandoc.org/ slug : Universal markup converter desc : | Pandoc is a Haskell library for converting from one markup format to another, and a command-line tool that uses this library. tags : - document-formats - convert - markdown labels : executable_type : binary language : haskell source : type : github_release user_name : jgm repo_name : pandoc url_regex : - https://github\\.com/jgm/pandoc/releases/download/(?P<version>.*)/pandoc-(?P=version)-(?P<os>[^-.]*)(-(?P<arch>[^-.]*))?(\\.tar\\.gz|\\.zip)$ aliases : arch : x86_64 : amd64 os : darwin : macOS artefact : type : archive transform : - bin/pandoc : mode : 755 path : pandoc You can use the explain subcommand to debug a package, and print out the data it collects: > bring explain pkg [path_to_pandoc_desc_file].pkg.br Package binaries.pandoc (Universal markup converter) desc Pandoc is a Haskell library for converting from one markup format to another, and a command-line tool that uses this library. homepage https://pandoc.org/ Variables arch The architecture the binary is built for. default -- no default -- required yes type string allowed amd64 (alias: x86_64) i386 os The operating system to run on. default -- no default -- required yes type string allowed 3 macOS (alias: darwin) linux osx windows version The version of the package. default latest required yes type string allowed 2.10.1 (aliases: stable, latest) 2.10 2.9.2.1 2.9.2 2.9.1.1 2.9.1 2.9 2.8.1 2.8.0.1 2.8 2.7.3 2.7.2 2.7.1 2.7 2.6 2.5 2.4 2.3.1 2.3 2.2.3.2 2.2.3.1 2.2.2.1 2.2.2 2.2.1 2.2 2.1.3 2.1.2 2.1.1 2.1 2.0.6 2.0.5 2.0.4 2.0.3 2.0.2 2.0.1.1 2.0.1 2.0.0.1 2.0 1.12.4.2","title":"Example"},{"location":"documentation/packages/package-description/#section-source","text":"A packacke description must have a section with the key source . Ideally, it describes a package in a way that is idempotent, which means that, if given the same input values, it'll always yield the exact same files, in the exact same folder structure. In some cases that is not possible/required, but we'll ignore that for now and assume idempotency. The source section itself can be split up into 3 different sub-sections:","title":"section: 'source'"},{"location":"documentation/packages/package-description/#key-type","text":"The name of the package type plugin that will read and process this data. bring supports multiple such package types, to accomodate for the different ways people publish their files. Currently available, official package types are: git_files : a package type to retrieve one or several files from a git repository git_repo : a package that represents a git repository and its content github_files : a package type to retrieve one or several files from a git repository that is hosted on GitHub github_release : a package type that tracks GitHub release artefacts gitlab_files : a package type to retrieve one or several files from a git repository that is hosted on GitLab template_url : a package type to resolve packages whose artifacts are published with static urls that can be templated","title":"key: 'type'"},{"location":"documentation/packages/package-description/#type-specific-keys","text":"Each package type has different required and optional arguments. Check their respective documentation for details.","title":"type-specific keys"},{"location":"documentation/packages/package-description/#common-keys-optional","text":"bring uses package-type plugins to retrieve source files for packages, but then uses the same code to post-process those files. This code also can take some input in order to costumize the final structure of a package. Those keys are currently supported:","title":"common keys (optional)"},{"location":"documentation/packages/package-description/#aliases","text":"A dictionary with the variable names as keys, and an alias dictionary (with alias as key, and final value as, well, ...value). E.g., for: os : linux : unknown-linux-gnu darwin : apple-darwin ...an input value of linux for the os variable would resolve to unknown-linux-gnu . Package types sometimes provider their own aliases (for example 'latest' as a pointer to the latest version of a github release).","title":"aliases"},{"location":"documentation/packages/package-description/#args","text":"A dictionary to let you control how package arguments are presented to the user. bring comes with default argument configurations for 3 argument keys: version , arch , os . If your package has other input variables (or if you want to override the defaults), you can do that here. Here is a list of available configuration keys (all of them optional): doc : a string describing the argument type : the type of the argument. supported: \"any\", \"string\", \"integer\", \"list\", \"dict\", \"boolean\" (and a few others, to be documented later -- defaults to \"any\") default : a default value if none is provided for the (no default) required : whether the argument is required or optional (defaults to 'true') multiple : whether a only a single, or multiple values are allowed (defaults to 'false') allowed : a list of allowed values (not implemented yet -- no default) As an example for the: the kubernetes.ingress requires an extra provider argument, to determine the exact yaml manifest file to select. This variable is described with data like: args : provider : doc : The provider to deploy to. default : cloud This will change the output of the package install help command to be: > bring install kubernetes.ingress-nginx --help Usage: bring install kubernetes.ingress-nginx [OPTIONS] Options: --provider PROVIDER The provider to deploy to. --version VERSION The version of the package. -h, --help Show this message and exit. And it will use cloud as value for that key if not specified otherwise by the user.","title":"args"},{"location":"documentation/packages/package-description/#artefact","text":"An optional hint to specify the type of source package artefact for a package (which could be a tar.gz- or zip-archive, a folder, a single-file, etc.). Internally, bring requires each package to be a folder containing one or several files. This argument helps transform single-file artefacts (archive, normal file) into a folder (for example by extracting it, or move a single downloaded file into a newly created temporary folder). In most cases, you won't need to specify it. For the cases where that is not true, those values are currently supported: file - a plain, single file folder - a folder (for example when the artefact is a git repository) archive - an archive file (currently supported archive types: zip, tar, tar.gz, tar.bz2, xtar) If artefact is not specified, a semi-smart detection mechanism is used (which should work for most cases).","title":"artefact"},{"location":"documentation/packages/package-description/#transform","text":"Optional configuration to control which files that are contained in the original artefact will end up in the package. This is the most used configuration option, as often you are not interested in supplementary files (licenses, configuration examples, etc.) to be installed into the target. Configuration for this value is done via providing a list of items as input. Each item can either be a string (for simple filtering), or a dictionary of values (if more advanced configuration is necessary). If no value for transform is provided, all files of the package will be copied into the target. If one or several list items are set, only those will be used, and all non-matching files will be ignored. If a list item is a string, the full path to that file is looked up in the source package folder, and copied over to the target using the exact same path/filename. If a dictionary is provided, those are the available configuration keys: from (required string): the path to the file/the filename in the source to (optional string): the target path/filename (defaults to the value of from ) mode (optional, string or integeer): the permissions of the file on the target (e.g. '0755', 644, ...) All variables that are used to resolve a version of a package are allowed in variable placeholders ( ${var_name} ). An full example from the binaries.k3d package, which renames an os-specificly named file to a more generic name, and also makes the file executable: transform : - path : k3d from : \"k3d-${ os }-amd64\" mode : 755 Other configuration keys are not supported currently, neither is selecting files via globs/regexs. There are plans to do that in the future though. Mixing string and dictionary items is allowed.","title":"transform"},{"location":"documentation/packages/package-description/#metadata-sections","text":"","title":"metadata sections:"},{"location":"documentation/packages/package-description/#section-info","text":"Contains information about the package itself, the most important sub-keys are: slug (description of the package), homepage .","title":"section: 'info'"},{"location":"documentation/packages/package-description/#section-tags","text":"A list of strings containing tags that apply to the package. This is not used at the moment, but will be later to filter/select packages.","title":"section: \"tags\""},{"location":"documentation/packages/package-description/#section-labels","text":"A list of strings containing labels that apply to the package. This is not used at the moment, but will be later to filter/select packages.","title":"section: \"labels\""},{"location":"documentation/packages/package-types/","text":"This page contains documentation and metadata for all package types that come with bring . The ' Args ' section in each item lists the argument each package type supports in the source part of a package description. For more details on how package descritions are build, check here type: git_files \u00b6 A package type to retrieve one or several files from a git repository. Arguments \u00b6 Name Description Type Required Default url The git repo url. string yes files The list of files to retrieve. list yes tag_filter if provided, is used as regex to select wanted tags string no Description \u00b6 Under the hood, this uses the git archive command to retrieve a zipped archive of the requested files, so when specifying the git url, make sure to either use the git or ssh protocol, or, if using https , that the remote server supports Smart HTTP (GitHub, for example, does not as far as I know). To filter out certain tags you don't want to end up as 'version's, you can use the tag_filter key, and specify a regular explression of 'allowed' tags. Templated file paths are not supported currently, but will be in the future. type: git_repo \u00b6 A package that represents a git repository and its content. Arguments \u00b6 Name Description Type Required Default url The git repo url. string yes use_commits_as_versions Whether to use commit hashes as version strings. boolean no Description \u00b6 The only argument required is the git repository url. bring will download and cache (unless otherwise configured) the whole repo. Depending on the repository size this might or might not be desirable. If the repository is large, and only one or a few files are wanted, it is probably better to use the git_files (or github_files , gitlab_files , ...) package type, as this only downloads the files needed. If one git repository is the shared source for multiple packages, this package type might be the better choice though, since it will be only downloaded and cached once, and retrieval of each of those packages is quicker (since the git repository is cached locally, and only a git checkout is necessary to retrieve a specific version). By default, all tags and branches will be used as version names. If ' use_commits_as_versions ' is set to ' true ', also the commit hashes will be used. An alias ' latest ' will be added, pointing to the latest tag, or, in case no tags exist, to the 'master' branch. Examples \u00b6 scripts.bashtop \u00b6 Package description: source : type : git_repo url : https://github.com/aristocratos/bashtop.git transform : - bashtop type: github_files \u00b6 A package type to retrieve one or several files from a git repository that is hosted on GitHub . Arguments \u00b6 Name Description Type Required Default user_name The github user name. string yes repo_name The github repo name. string yes files The list of files to retrieve. string yes tag_filter if provided, is used as regex to select wanted tags string no template_values An (optional) map with the possible template var names in the value for 'files' as keys, and all allowed values for each key as value. dict no Description \u00b6 This package type directly downloads the required files from GitHub, without downloading the repository itself first. This way of accessing files is advantageous if you only need a few, small files, and the repository itself is on the larger side. If this is not the case, consider using the ' git_repo ' package type. File-paths specified in the files argument can contain template place-holders (like: deploy/${provider}/config.json ). If that is the case, you need to provide a list of possible values for each of the included placeholders in the template_values key (check the example below). Examples \u00b6 kubernetes.ingress-nginx \u00b6 Package description: source : use_commits_as_versions : false type : github_files user_name : kubernetes repo_name : ingress-nginx tag_filter : ingress-nginx-.* files : - deploy/static/provider/${provider}/deploy.yaml args : provider : doc : The provider to deploy to. template_values : provider : - baremetal - cloud - aws - do transform : - path : deploy.yaml from : deploy/static/provider/${provider}/deploy.yaml type: github_release \u00b6 A package type that tracks GitHub release artefacts. Arguments \u00b6 Name Description Type Required Default user_name The github user name. string yes repo_name The github repo name. string yes url_regex The url regex to parse the release urls. string no Description \u00b6 To be able to get a list of all releases and their metadata, a package needs to specify the github user- and repo-names, as well as a regex to parse the release urls and compute the variables (version, architecture, os, etc.) involved to assemble a list of versions for a package. This is a barebones example for a source definition for the fd application: source : type : github-release user_name : sharkdp repo_name : fd url_regex : 'https://github.com/.*/releases/download/v(?P<version>.*)/.*-v(?P=version)-(?P<arch>[^-]*)-(?P<os>[^.]*)\\..*$' More than one such regular expressions can be provided (in which case the value for url_regex should be a list), all matches for all regexes will be added to the resulting list. Most of the regexes for different packages look fairly similar, but unfortunately Github release-urls don't follow a standard, which makes it impossible to come up with one that can be used for all of them. bring comes with a default regex that works for quite a few Github projects (and almost for a lot of others). In fact, the regex in the example above is the default regex that will be used if no ' url_regex ' value is provided, and it so happens that it works for ' fd ' (which means we could have omitted it for that particular application). Nonetheless, whoever creates a new package manifest needs to manually verify whether the default regex works, and then adjust or create a totally different one if necessary. Examples \u00b6 binaries.k3d \u00b6 Package description: source : type : github_release user_name : rancher repo_name : k3d url_regex : - https://github.com/.*/releases/download/v(?P<version>.*)/k3d-(?P<os>[^-]*)-(?P<arch>[^.]*)$ aliases : arch : x86_64 : amd64 artefact : type : file transform : - path : k3d from : k3d-${ os }-amd64 mode : 755 kubernetes.cert-manager \u00b6 Package description: source : type : github_release user_name : jetstack repo_name : cert-manager url_regex : - https://github.com/jetstack/cert-manager/releases/download/v(?P<version>.*)/cert-manager.yaml$ type: gitlab_files \u00b6 A package type to retrieve one or several files from a git repository that is hosted on GitLab . Arguments \u00b6 Name Description Type Required Default user_name The gitlab user name. string yes repo_name The gitlab repo path (not internal name, which is different in some cases). string yes files The list of files to retrieve. string yes tag_filter if provided, is used as regex to select wanted tags string no template_values An (optional) map with the possible template var names in the value for 'files' as keys, and all allowed values for each key as value. dict no Description \u00b6 This package type directly downloads the required files from GitLab, without retrieving the repository itself first. This way of accessing files is advantageous if you only need a few, small files, and the repository itself is on the larger side. If this is not the case, consider using the ' git_repo ' package type. File-paths specified in the files argument can contain template place-holders (like: deploy/${provider}/config.json ). If that is the case, you need to provide a list of possible values for each of the included placeholders in the template_values key (check the example below). type: template_url \u00b6 A package type to resolve packages whose artifacts are published with static urls that can be templated. Arguments \u00b6 Name Description Type Required Default template_values A map with the possible template var names as keys, and all allowed values for each key as value. dict yes url The templated url string, using ' string yes Description \u00b6 All values of all template variables are combined with each of the other template variables to create a matrix of possible combinations. In some cases some of those combinations are not valid, and lead to a url that does not resolve to a file to download. At this time, there is nothing that can be done about it and the user will see an error message. Examples \u00b6 binaries.kubectl \u00b6 Package description: source : type : template_url url : https://storage.googleapis.com/kubernetes-release/release/v${version}/bin/${os}/${arch}/kubectl template_values : version : - 1.18.6 - 1.18.5 - 1.18.4 - 1.18.3 - 1.18.2 - 1.18.1 - 1.18.0 - 1.17.9 - 1.17.8 - 1.17.7 - 1.17.6 - 1.17.5 - 1.17.4 - 1.17.3 - 1.17.2 - 1.17.1 - 1.17.0 - 1.16.13 - 1.16.12 os : - darwin - linux - windows arch : - amd64 - arm - i386 aliases : arch : x86_64 : amd64 transform : kubectl : mode : 755 binaries.helm \u00b6 Package description: source : type : template_url url : https://get.helm.sh/helm-v${version}-${os}-${arch}.tar.gz template_values : version : - 3.2.4 - 3.2.3 - 3.2.2 - 3.2.1 - 3.2.0 - 3.1.3 - 3.1.2 - 3.1.1 - 3.1.0 - 3.0.3 - 3.0.2 - 3.0.1 - 3.0.0 - 2.16.9 - 2.16.8 - 2.16.7 - 2.16.6 - 2.16.5 - 2.16.4 - 2.16.3 os : - darwin - linux - windows arch : - amd64 - arm - i386 aliases : arch : x86_64 : amd64 transform : - helm","title":"Package types"},{"location":"documentation/packages/package-types/#type-git_files","text":"A package type to retrieve one or several files from a git repository.","title":"type: git_files"},{"location":"documentation/packages/package-types/#arguments","text":"Name Description Type Required Default url The git repo url. string yes files The list of files to retrieve. list yes tag_filter if provided, is used as regex to select wanted tags string no","title":"Arguments"},{"location":"documentation/packages/package-types/#description","text":"Under the hood, this uses the git archive command to retrieve a zipped archive of the requested files, so when specifying the git url, make sure to either use the git or ssh protocol, or, if using https , that the remote server supports Smart HTTP (GitHub, for example, does not as far as I know). To filter out certain tags you don't want to end up as 'version's, you can use the tag_filter key, and specify a regular explression of 'allowed' tags. Templated file paths are not supported currently, but will be in the future.","title":"Description"},{"location":"documentation/packages/package-types/#type-git_repo","text":"A package that represents a git repository and its content.","title":"type: git_repo"},{"location":"documentation/packages/package-types/#arguments_1","text":"Name Description Type Required Default url The git repo url. string yes use_commits_as_versions Whether to use commit hashes as version strings. boolean no","title":"Arguments"},{"location":"documentation/packages/package-types/#description_1","text":"The only argument required is the git repository url. bring will download and cache (unless otherwise configured) the whole repo. Depending on the repository size this might or might not be desirable. If the repository is large, and only one or a few files are wanted, it is probably better to use the git_files (or github_files , gitlab_files , ...) package type, as this only downloads the files needed. If one git repository is the shared source for multiple packages, this package type might be the better choice though, since it will be only downloaded and cached once, and retrieval of each of those packages is quicker (since the git repository is cached locally, and only a git checkout is necessary to retrieve a specific version). By default, all tags and branches will be used as version names. If ' use_commits_as_versions ' is set to ' true ', also the commit hashes will be used. An alias ' latest ' will be added, pointing to the latest tag, or, in case no tags exist, to the 'master' branch.","title":"Description"},{"location":"documentation/packages/package-types/#examples","text":"","title":"Examples"},{"location":"documentation/packages/package-types/#scriptsbashtop","text":"Package description: source : type : git_repo url : https://github.com/aristocratos/bashtop.git transform : - bashtop","title":"scripts.bashtop"},{"location":"documentation/packages/package-types/#type-github_files","text":"A package type to retrieve one or several files from a git repository that is hosted on GitHub .","title":"type: github_files"},{"location":"documentation/packages/package-types/#arguments_2","text":"Name Description Type Required Default user_name The github user name. string yes repo_name The github repo name. string yes files The list of files to retrieve. string yes tag_filter if provided, is used as regex to select wanted tags string no template_values An (optional) map with the possible template var names in the value for 'files' as keys, and all allowed values for each key as value. dict no","title":"Arguments"},{"location":"documentation/packages/package-types/#description_2","text":"This package type directly downloads the required files from GitHub, without downloading the repository itself first. This way of accessing files is advantageous if you only need a few, small files, and the repository itself is on the larger side. If this is not the case, consider using the ' git_repo ' package type. File-paths specified in the files argument can contain template place-holders (like: deploy/${provider}/config.json ). If that is the case, you need to provide a list of possible values for each of the included placeholders in the template_values key (check the example below).","title":"Description"},{"location":"documentation/packages/package-types/#examples_1","text":"","title":"Examples"},{"location":"documentation/packages/package-types/#kubernetesingress-nginx","text":"Package description: source : use_commits_as_versions : false type : github_files user_name : kubernetes repo_name : ingress-nginx tag_filter : ingress-nginx-.* files : - deploy/static/provider/${provider}/deploy.yaml args : provider : doc : The provider to deploy to. template_values : provider : - baremetal - cloud - aws - do transform : - path : deploy.yaml from : deploy/static/provider/${provider}/deploy.yaml","title":"kubernetes.ingress-nginx"},{"location":"documentation/packages/package-types/#type-github_release","text":"A package type that tracks GitHub release artefacts.","title":"type: github_release"},{"location":"documentation/packages/package-types/#arguments_3","text":"Name Description Type Required Default user_name The github user name. string yes repo_name The github repo name. string yes url_regex The url regex to parse the release urls. string no","title":"Arguments"},{"location":"documentation/packages/package-types/#description_3","text":"To be able to get a list of all releases and their metadata, a package needs to specify the github user- and repo-names, as well as a regex to parse the release urls and compute the variables (version, architecture, os, etc.) involved to assemble a list of versions for a package. This is a barebones example for a source definition for the fd application: source : type : github-release user_name : sharkdp repo_name : fd url_regex : 'https://github.com/.*/releases/download/v(?P<version>.*)/.*-v(?P=version)-(?P<arch>[^-]*)-(?P<os>[^.]*)\\..*$' More than one such regular expressions can be provided (in which case the value for url_regex should be a list), all matches for all regexes will be added to the resulting list. Most of the regexes for different packages look fairly similar, but unfortunately Github release-urls don't follow a standard, which makes it impossible to come up with one that can be used for all of them. bring comes with a default regex that works for quite a few Github projects (and almost for a lot of others). In fact, the regex in the example above is the default regex that will be used if no ' url_regex ' value is provided, and it so happens that it works for ' fd ' (which means we could have omitted it for that particular application). Nonetheless, whoever creates a new package manifest needs to manually verify whether the default regex works, and then adjust or create a totally different one if necessary.","title":"Description"},{"location":"documentation/packages/package-types/#examples_2","text":"","title":"Examples"},{"location":"documentation/packages/package-types/#binariesk3d","text":"Package description: source : type : github_release user_name : rancher repo_name : k3d url_regex : - https://github.com/.*/releases/download/v(?P<version>.*)/k3d-(?P<os>[^-]*)-(?P<arch>[^.]*)$ aliases : arch : x86_64 : amd64 artefact : type : file transform : - path : k3d from : k3d-${ os }-amd64 mode : 755","title":"binaries.k3d"},{"location":"documentation/packages/package-types/#kubernetescert-manager","text":"Package description: source : type : github_release user_name : jetstack repo_name : cert-manager url_regex : - https://github.com/jetstack/cert-manager/releases/download/v(?P<version>.*)/cert-manager.yaml$","title":"kubernetes.cert-manager"},{"location":"documentation/packages/package-types/#type-gitlab_files","text":"A package type to retrieve one or several files from a git repository that is hosted on GitLab .","title":"type: gitlab_files"},{"location":"documentation/packages/package-types/#arguments_4","text":"Name Description Type Required Default user_name The gitlab user name. string yes repo_name The gitlab repo path (not internal name, which is different in some cases). string yes files The list of files to retrieve. string yes tag_filter if provided, is used as regex to select wanted tags string no template_values An (optional) map with the possible template var names in the value for 'files' as keys, and all allowed values for each key as value. dict no","title":"Arguments"},{"location":"documentation/packages/package-types/#description_4","text":"This package type directly downloads the required files from GitLab, without retrieving the repository itself first. This way of accessing files is advantageous if you only need a few, small files, and the repository itself is on the larger side. If this is not the case, consider using the ' git_repo ' package type. File-paths specified in the files argument can contain template place-holders (like: deploy/${provider}/config.json ). If that is the case, you need to provide a list of possible values for each of the included placeholders in the template_values key (check the example below).","title":"Description"},{"location":"documentation/packages/package-types/#type-template_url","text":"A package type to resolve packages whose artifacts are published with static urls that can be templated.","title":"type: template_url"},{"location":"documentation/packages/package-types/#arguments_5","text":"Name Description Type Required Default template_values A map with the possible template var names as keys, and all allowed values for each key as value. dict yes url The templated url string, using ' string yes","title":"Arguments"},{"location":"documentation/packages/package-types/#description_5","text":"All values of all template variables are combined with each of the other template variables to create a matrix of possible combinations. In some cases some of those combinations are not valid, and lead to a url that does not resolve to a file to download. At this time, there is nothing that can be done about it and the user will see an error message.","title":"Description"},{"location":"documentation/packages/package-types/#examples_3","text":"","title":"Examples"},{"location":"documentation/packages/package-types/#binarieskubectl","text":"Package description: source : type : template_url url : https://storage.googleapis.com/kubernetes-release/release/v${version}/bin/${os}/${arch}/kubectl template_values : version : - 1.18.6 - 1.18.5 - 1.18.4 - 1.18.3 - 1.18.2 - 1.18.1 - 1.18.0 - 1.17.9 - 1.17.8 - 1.17.7 - 1.17.6 - 1.17.5 - 1.17.4 - 1.17.3 - 1.17.2 - 1.17.1 - 1.17.0 - 1.16.13 - 1.16.12 os : - darwin - linux - windows arch : - amd64 - arm - i386 aliases : arch : x86_64 : amd64 transform : kubectl : mode : 755","title":"binaries.kubectl"},{"location":"documentation/packages/package-types/#binarieshelm","text":"Package description: source : type : template_url url : https://get.helm.sh/helm-v${version}-${os}-${arch}.tar.gz template_values : version : - 3.2.4 - 3.2.3 - 3.2.2 - 3.2.1 - 3.2.0 - 3.1.3 - 3.1.2 - 3.1.1 - 3.1.0 - 3.0.3 - 3.0.2 - 3.0.1 - 3.0.0 - 2.16.9 - 2.16.8 - 2.16.7 - 2.16.6 - 2.16.5 - 2.16.4 - 2.16.3 os : - darwin - linux - windows arch : - amd64 - arm - i386 aliases : arch : x86_64 : amd64 transform : - helm","title":"binaries.helm"},{"location":"documentation/plugins/mogrifiers/","text":"","title":"Mogrifiers"},{"location":"getting-started/creating-packages/","text":"This guide walks you through the creation of your first bring package. For details about the package description format, available package types and other more in-depth in formation check out the package description documentation . Create the package description file \u00b6 For this example, we'll create a package for one of the files in this example git repository , specifically this file . Since the file we are interested in is hosted on Gitlab, and we only are interested in this particular file and not the whole repository, we will use the gitlab_files package type. ...using the create pkg-desc sub-command \u00b6 bring package types come with some helpers to make it easier to create package descriptions by auto-filling in some required and/or default values. Without any arguments (apart from the required package type name), bring create pkg-desc [package-type] will return a bare package description string, which you can use as a starting point by copying it into a file and filling in some required values: > bring create pkg-desc gitlab_files --- # info: # slug: < package_description > # homepage: ' https://example.com ' # tags: # - < tag1 > # - < tag2 > # labels: # < key > : < value > # # e.g.: # language: < language > source: type: gitlab_files user_name: < string_value > # required repo_name: < string_value > # required files: < string_value > # required # tag_filter: < string_value > # optional # template_values: < dict_value > # optional # aliases: # < var_name > : # < alias > : < actual_value > # < alias_2 > : < actual_value_2 > # # e.g.: # arch: # x86_64: x86- 64 # artefact: # # possible values: file, folder, archive # type: archive # transform: # # filter by path of the original source file # - < orig_file > # # or, filter original source file, but rename/move # - < orig_file > : < target_path > # # or, filter original source file, but rename/move and/or change file mode # - from: < orig_file > # path: < target_path > # mode: '0755' We can also tell bring to create the package description file straight away: > bring create pkg-desc gitlab_files -f example-file1 Saved package descrition to: /home/runner/work/bring/bring/ example-file1.pkg.br Note : if no file extension is provided, bring will use the default ' .pkg.br ' We can now go through that file, and fill in the 3 required values for the gitlab_files package type: user_name : in our case bring-indexes repo_name : here we use example-source-repo files : we only want one file, so we use a single-item list: ['some-files/file1.md'] Once that is done, we can use the explain sub-command to get the details of our newly create package: > bring explain package example_file1.pkg.br Package example_file1.pkg.br Variables version The version of the package. default latest required yes type string allowed v1.1.0 (alias: latest) v1.0.0 master develop As you can see in that output, bring determined the available versions, and selected an appropriate alias for the latest tag. We could now comment out some of the metadata fields and fill in some of the values manually. Or we could be... ...using the create pkg-desc command with arguments \u00b6 Some package type plugins support auto-filling some of the metadata (and other) values of a package description, given enough basic information. For the gitlab_files plugin we can find out which values are required by issuing: > bring create pkg-desc gitlab_files --help Usage: bring create pkg-desc gitlab_files [OPTIONS] [PKG_NAME_OR_PATH] Options: --files FILES The list of files to retrieve. --repo-name REPO_NAME The gitlab repo path (not internal name, which is different in some cases). --tag-filter TAG_FILTER if provided, is used as regex to select wanted tags --template-values TEMPLATE_VALUES An (optional) map with the possible template var names in the value for 'files' as keys, and all allowed values for each key as value. --user-name USER_NAME The gitlab user name. -f, --force overwrite existing package description -h, --help Show this message and exit. Let's try that: > bring create pkg-desc gitlab_files --user-name bring-indexes --repo-name example-source-repo --files some-file/file1.md --- info: slug: Example files to turn into bring packages. homepage: https://gitlab.com/bring-indexes/example-source-repo # tags: # - < tag1 > # - < tag2 > # labels: # < key > : < value > # # e.g.: # language: < language > source: type: gitlab_files user_name: bring-indexes repo_name: example-source-repo files: - some-file/file1.md # tag_filter: < string_value > # optional # template_values: < dict_value > # optional # aliases: # < var_name > : # < alias > : < actual_value > # < alias_2 > : < actual_value_2 > # # e.g.: # arch: # x86_64: x86- 64 # artefact: # # possible values: file, folder, archive # type: archive # transform: # # filter by path of the original source file # - < orig_file > # # or, filter original source file, but rename/move # - < orig_file > : < target_path > # # or, filter original source file, but rename/move and/or change file mode # - from: < orig_file > # path: < target_path > # mode: '0755' As with the example above, we can use a file-path argument at the end of this command to write this description to a file straight away. This description should be usable without any further manual editing, since we provided all required values via the command-line. Plus, bring added some of the metadata in 'info' automatically (which we could change, if we don't like it).","title":"Creating a package"},{"location":"getting-started/creating-packages/#create-the-package-description-file","text":"For this example, we'll create a package for one of the files in this example git repository , specifically this file . Since the file we are interested in is hosted on Gitlab, and we only are interested in this particular file and not the whole repository, we will use the gitlab_files package type.","title":"Create the package description file"},{"location":"getting-started/creating-packages/#using-the-create-pkg-desc-sub-command","text":"bring package types come with some helpers to make it easier to create package descriptions by auto-filling in some required and/or default values. Without any arguments (apart from the required package type name), bring create pkg-desc [package-type] will return a bare package description string, which you can use as a starting point by copying it into a file and filling in some required values: > bring create pkg-desc gitlab_files --- # info: # slug: < package_description > # homepage: ' https://example.com ' # tags: # - < tag1 > # - < tag2 > # labels: # < key > : < value > # # e.g.: # language: < language > source: type: gitlab_files user_name: < string_value > # required repo_name: < string_value > # required files: < string_value > # required # tag_filter: < string_value > # optional # template_values: < dict_value > # optional # aliases: # < var_name > : # < alias > : < actual_value > # < alias_2 > : < actual_value_2 > # # e.g.: # arch: # x86_64: x86- 64 # artefact: # # possible values: file, folder, archive # type: archive # transform: # # filter by path of the original source file # - < orig_file > # # or, filter original source file, but rename/move # - < orig_file > : < target_path > # # or, filter original source file, but rename/move and/or change file mode # - from: < orig_file > # path: < target_path > # mode: '0755' We can also tell bring to create the package description file straight away: > bring create pkg-desc gitlab_files -f example-file1 Saved package descrition to: /home/runner/work/bring/bring/ example-file1.pkg.br Note : if no file extension is provided, bring will use the default ' .pkg.br ' We can now go through that file, and fill in the 3 required values for the gitlab_files package type: user_name : in our case bring-indexes repo_name : here we use example-source-repo files : we only want one file, so we use a single-item list: ['some-files/file1.md'] Once that is done, we can use the explain sub-command to get the details of our newly create package: > bring explain package example_file1.pkg.br Package example_file1.pkg.br Variables version The version of the package. default latest required yes type string allowed v1.1.0 (alias: latest) v1.0.0 master develop As you can see in that output, bring determined the available versions, and selected an appropriate alias for the latest tag. We could now comment out some of the metadata fields and fill in some of the values manually. Or we could be...","title":"...using the create pkg-desc sub-command"},{"location":"getting-started/creating-packages/#using-the-create-pkg-desc-command-with-arguments","text":"Some package type plugins support auto-filling some of the metadata (and other) values of a package description, given enough basic information. For the gitlab_files plugin we can find out which values are required by issuing: > bring create pkg-desc gitlab_files --help Usage: bring create pkg-desc gitlab_files [OPTIONS] [PKG_NAME_OR_PATH] Options: --files FILES The list of files to retrieve. --repo-name REPO_NAME The gitlab repo path (not internal name, which is different in some cases). --tag-filter TAG_FILTER if provided, is used as regex to select wanted tags --template-values TEMPLATE_VALUES An (optional) map with the possible template var names in the value for 'files' as keys, and all allowed values for each key as value. --user-name USER_NAME The gitlab user name. -f, --force overwrite existing package description -h, --help Show this message and exit. Let's try that: > bring create pkg-desc gitlab_files --user-name bring-indexes --repo-name example-source-repo --files some-file/file1.md --- info: slug: Example files to turn into bring packages. homepage: https://gitlab.com/bring-indexes/example-source-repo # tags: # - < tag1 > # - < tag2 > # labels: # < key > : < value > # # e.g.: # language: < language > source: type: gitlab_files user_name: bring-indexes repo_name: example-source-repo files: - some-file/file1.md # tag_filter: < string_value > # optional # template_values: < dict_value > # optional # aliases: # < var_name > : # < alias > : < actual_value > # < alias_2 > : < actual_value_2 > # # e.g.: # arch: # x86_64: x86- 64 # artefact: # # possible values: file, folder, archive # type: archive # transform: # # filter by path of the original source file # - < orig_file > # # or, filter original source file, but rename/move # - < orig_file > : < target_path > # # or, filter original source file, but rename/move and/or change file mode # - from: < orig_file > # path: < target_path > # mode: '0755' As with the example above, we can use a file-path argument at the end of this command to write this description to a file straight away. This description should be usable without any further manual editing, since we provided all required values via the command-line. Plus, bring added some of the metadata in 'info' automatically (which we could change, if we don't like it).","title":"...using the create pkg-desc command with arguments"},{"location":"getting-started/information/","text":"List default indexes \u00b6 To quickly get a list of available indexes and packages, use the list sub-command: > bring list binaries argo Container native workflow engine for Kubernetes supporting both DAG and step based workflows. argo-cd Declarative continuous deployment for Kubernetes. bat a 'cat' clone with wings. dbmate a database migration tool dust like du but more intuitive eclectica Cool and eclectic version manager for any language eclectica-proxy Cool and eclectic version manager for any language fd fd is a simple, fast and user-friendly alternative to find. helm A Kubernetes Package Manager hugo a static site generator k3d Little helper to run Rancher Lab's k3s in Docker k3sup from Zero to KUBECONFIG in less than 1 min kube-prompt An interactive kubernetes client featuring auto-complete. kubectl kubectl controls the Kubernetes cluster manager lazydocker The lazier way to manage everything docker lazygit simple terminal UI for git commands lsd The next gen ls command mitmproxy An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers. navi an interactive cheatsheet tool for the command-line nnn The missing terminal file manager for X. pandoc Universal markup converter terminal-to-html Converts arbitrary shell output (with ANSI) into beautifully rendered HTML tldr Golang command line client for tldr tubectl kubectl alternative with quick context switching, kubectl on steroids wrangler \ud83e\udd20 wrangle your cloudflare workers ytop A TUI system monitor written in Rust zoxide A fast cd command that learns your habits scripts bashtop Linux resource monitor kubectx Faster way to switch between clusters in kubectl kubens Faster way to switch between namespaces in kubectl kubernetes argo-cd Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. cert-manager Automatically provision and manage TLS certificates in Kubernetes ingress-nginx NGINX Ingress Controller for Kubernetes collections templates Templates collection Display information \u00b6 In order to get more information about an index or package, you can use the explain sub-command. Use either index or package as first argument, and the name of the index or package as second. Index metadata \u00b6 This is how to get metadata for the binaries index: > bring explain index binaries binaries (Single file, compiled applications.) desc This index contains single-file binaries that don't require any dependencies to be installed in order to work. By default, those binaries will be installed into '$HOME/.local/bring', using the default 'bring' merge strategy (save metadata about each installed file, more information can be found here . metadata_timestamp a day ago uri https://gitlab.com/bring-indexes/binaries/-/raw/master/.bring/this.idx.br defaults arch : x86_64 node : fv-az70 os : linux target : ~/.local/bring index_type git_repo config git_url : https://gitlab.com/bring-indexes/binaries.git version : master packages argo Container native workflow engine for Kubernetes supporting both DAG and step based workflows. argo-cd Declarative continuous deployment for Kubernetes. bat a 'cat' clone with wings. dbmate a database migration tool dust like du but more intuitive eclectica Cool and eclectic version manager for any language eclectica-proxy Cool and eclectic version manager for any language fd fd is a simple, fast and user-friendly alternative to find. helm A Kubernetes Package Manager hugo a static site generator k3d Little helper to run Rancher Lab's k3s in Docker k3sup from Zero to KUBECONFIG in less than 1 min kube-prompt An interactive kubernetes client featuring auto-complete. kubectl kubectl controls the Kubernetes cluster manager lazydocker The lazier way to manage everything docker lazygit simple terminal UI for git commands lsd The next gen ls command mitmproxy An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers. navi an interactive cheatsheet tool for the command-line nnn The missing terminal file manager for X. pandoc Universal markup converter terminal-to-html Converts arbitrary shell output (with ANSI) into beautifully rendered HTML tldr Golang command line client for tldr tubectl kubectl alternative with quick context switching, kubectl on steroids wrangler \ud83e\udd20 wrangle your cloudflare workers ytop A TUI system monitor written in Rust zoxide A fast cd command that learns your habits Package metadata \u00b6 And this is how to get the details for the fd package that is a part of the binaries index: > bring explain package binaries.fd Package binaries.fd (fd is a simple, fast and user-friendly alternative to find.) license - Apache v2.0 - MIT author github_user: sharkdp name: David Peter homepage: http://david-peter.de/ homepage https://github.com/sharkdp/fd urls tutorial: https://github.com/sharkdp/fd#tutorial Variables arch The architecture the binary is built for. default -- no default -- required yes type string allowed arm i686 x86_64 os The operating system to run on. default -- no default -- required yes type string allowed apple-darwin (alias: darwin) unknown-linux-gnu (alias: linux) unknown-linux-musl (alias: linux-musl) pc-windows-gnu pc-windows-msvc unknown-linux-gnueabihf unknown-linux-musleabihf version The version of the package. default latest required yes type string allowed 8.1.1 (aliases: stable, latest) 8.1.0 8.0.0 7.5.0 7.4.0 7.3.0 7.2.0 7.1.0 7.0.0 6.3.0 6.2.0 6.1.0 6.0.0 5.0.0 4.0.0","title":"Getting information"},{"location":"getting-started/information/#list-default-indexes","text":"To quickly get a list of available indexes and packages, use the list sub-command: > bring list binaries argo Container native workflow engine for Kubernetes supporting both DAG and step based workflows. argo-cd Declarative continuous deployment for Kubernetes. bat a 'cat' clone with wings. dbmate a database migration tool dust like du but more intuitive eclectica Cool and eclectic version manager for any language eclectica-proxy Cool and eclectic version manager for any language fd fd is a simple, fast and user-friendly alternative to find. helm A Kubernetes Package Manager hugo a static site generator k3d Little helper to run Rancher Lab's k3s in Docker k3sup from Zero to KUBECONFIG in less than 1 min kube-prompt An interactive kubernetes client featuring auto-complete. kubectl kubectl controls the Kubernetes cluster manager lazydocker The lazier way to manage everything docker lazygit simple terminal UI for git commands lsd The next gen ls command mitmproxy An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers. navi an interactive cheatsheet tool for the command-line nnn The missing terminal file manager for X. pandoc Universal markup converter terminal-to-html Converts arbitrary shell output (with ANSI) into beautifully rendered HTML tldr Golang command line client for tldr tubectl kubectl alternative with quick context switching, kubectl on steroids wrangler \ud83e\udd20 wrangle your cloudflare workers ytop A TUI system monitor written in Rust zoxide A fast cd command that learns your habits scripts bashtop Linux resource monitor kubectx Faster way to switch between clusters in kubectl kubens Faster way to switch between namespaces in kubectl kubernetes argo-cd Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. cert-manager Automatically provision and manage TLS certificates in Kubernetes ingress-nginx NGINX Ingress Controller for Kubernetes collections templates Templates collection","title":"List default indexes"},{"location":"getting-started/information/#display-information","text":"In order to get more information about an index or package, you can use the explain sub-command. Use either index or package as first argument, and the name of the index or package as second.","title":"Display information"},{"location":"getting-started/information/#index-metadata","text":"This is how to get metadata for the binaries index: > bring explain index binaries binaries (Single file, compiled applications.) desc This index contains single-file binaries that don't require any dependencies to be installed in order to work. By default, those binaries will be installed into '$HOME/.local/bring', using the default 'bring' merge strategy (save metadata about each installed file, more information can be found here . metadata_timestamp a day ago uri https://gitlab.com/bring-indexes/binaries/-/raw/master/.bring/this.idx.br defaults arch : x86_64 node : fv-az70 os : linux target : ~/.local/bring index_type git_repo config git_url : https://gitlab.com/bring-indexes/binaries.git version : master packages argo Container native workflow engine for Kubernetes supporting both DAG and step based workflows. argo-cd Declarative continuous deployment for Kubernetes. bat a 'cat' clone with wings. dbmate a database migration tool dust like du but more intuitive eclectica Cool and eclectic version manager for any language eclectica-proxy Cool and eclectic version manager for any language fd fd is a simple, fast and user-friendly alternative to find. helm A Kubernetes Package Manager hugo a static site generator k3d Little helper to run Rancher Lab's k3s in Docker k3sup from Zero to KUBECONFIG in less than 1 min kube-prompt An interactive kubernetes client featuring auto-complete. kubectl kubectl controls the Kubernetes cluster manager lazydocker The lazier way to manage everything docker lazygit simple terminal UI for git commands lsd The next gen ls command mitmproxy An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers. navi an interactive cheatsheet tool for the command-line nnn The missing terminal file manager for X. pandoc Universal markup converter terminal-to-html Converts arbitrary shell output (with ANSI) into beautifully rendered HTML tldr Golang command line client for tldr tubectl kubectl alternative with quick context switching, kubectl on steroids wrangler \ud83e\udd20 wrangle your cloudflare workers ytop A TUI system monitor written in Rust zoxide A fast cd command that learns your habits","title":"Index metadata"},{"location":"getting-started/information/#package-metadata","text":"And this is how to get the details for the fd package that is a part of the binaries index: > bring explain package binaries.fd Package binaries.fd (fd is a simple, fast and user-friendly alternative to find.) license - Apache v2.0 - MIT author github_user: sharkdp name: David Peter homepage: http://david-peter.de/ homepage https://github.com/sharkdp/fd urls tutorial: https://github.com/sharkdp/fd#tutorial Variables arch The architecture the binary is built for. default -- no default -- required yes type string allowed arm i686 x86_64 os The operating system to run on. default -- no default -- required yes type string allowed apple-darwin (alias: darwin) unknown-linux-gnu (alias: linux) unknown-linux-musl (alias: linux-musl) pc-windows-gnu pc-windows-msvc unknown-linux-gnueabihf unknown-linux-musleabihf version The version of the package. default latest required yes type string allowed 8.1.1 (aliases: stable, latest) 8.1.0 8.0.0 7.5.0 7.4.0 7.3.0 7.2.0 7.1.0 7.0.0 6.3.0 6.2.0 6.1.0 6.0.0 5.0.0 4.0.0","title":"Package metadata"},{"location":"getting-started/installing-packages/","text":"Install a package \u00b6 When you don't need a specific version of a package, you can install a package... ... using only default values \u00b6 To install one of the available packages without any customization, all you need to do is specify the full name for the package: > bring install binaries.fd Task : installing package 'fd' Variables arch x86_64 origin: index defaults os unknown-linux-gnu origin: index defaults, from alias: linux pkg binaries.fd origin: user input target ~/.local/bring origin: index defaults target_config -- no value -- transform -- no value -- version 8.1.1 origin: package defaults, from alias: latest Progress - installing pkg 'fd' -> done - gathering file ( s ) for package 'fd' -> done - downloading file: https://github.com/sharkdp/fd/releases/download/v8.1.1/fd-v8.1.1-x86_64-unknown-linux-gnu.tar.gz -> done - extracting archive ( disregarding root folder, only using contents of it ) -> done - validating package content -> done - merging files into folder '~/.local/bring' -> done Result: - merged items into ' /home/runner/.local/bring ': fd : merged bring always tries be as clear as possible as to what it is doing, which is why it prints the values it ends up using, as well as their origin. For example, as you can see from the output of that command, the fd binary file was installed into the local $HOME/.local/bring folder. This is because that is the default folder for the binaries index (check the 'explain' command documentation on how to get that information). In addition to the target default, that index also comes with a set of auto-generated default values that describe the OS and architecture of the system bring is running on (which is helpful to pick the right version of a binary, for example). In some cases the default target might not be suitable for you though. In that case, you can install the package... ... into a specific folder \u00b6 If you need to install a package into a specific directory, use the --target parameter: > bring install --target /tmp/bring binaries.fd Task : installing package 'fd' Variables arch x86_64 origin: index defaults os unknown-linux-gnu origin: index defaults, from alias: linux pkg binaries.fd origin: user input target /tmp/bring origin: user input target_config -- no value -- transform -- no value -- version 8.1.1 origin: package defaults, from alias: latest Progress ... ... ... Result: - merged items into ' /tmp/bring ': fd : merged The target folder, as well as any intermediate ones, will be created in case they don't exist yet. If you don't specify the --target parameter, and the index does not have a default target set, the files will be copied into a temporary directory somewhere under ~/.local/share/bring/workspace/results/ : > bring install kubernetes.cert-manager Task : installing package 'cert-manager' ... ... ... Result: - merged items into ' /home/runner/.cache/bring/workspace/results/install__wpayo_gs ': cert-manager.yaml : merged To have more fine-grained control of the version of the package to install, you have to use the install command... ... with arguments \u00b6 Packages often come in different flavours (e.g. which architecture, OS, etc.), as well as several versions, which can be specified in the install command after the package name. Depending on the index configuration, bring assumes certain default values which often make it so that no package arguments at all need to be provided. But, often it is advisable to specify the exact version of a package to install. If that is desired, you can use the --help parameter (after the package name) to get bring to display information about the supported arguments: > bring install binaries.fd --help Usage: bring install binaries.fd [OPTIONS] Options: --arch ARCH The architecture the binary is built for. --os OS The operating system to run on. --version VERSION The version of the package. -h, --help Show this message and exit. To check which values are allowed, the explain subcommand is often useful (like the one we used here ). To illustrate, the following is an example showing how to specifically install version '7.1.0' of the Mac OS X variant of fd : > bring install binaries.fd --version 7.1.0 --os darwin Task : installing package 'fd' Variables arch x86_64 origin: index defaults os apple-darwin origin: user input, from alias: darwin pkg binaries.fd origin: user input target ~/.local/bring origin: index defaults target_config -- no value -- transform -- no value -- version 7.1.0 origin: user input ... ... ... Result: - merged items into ' /home/runner/.local/bring ': fd : file exists, not merged Install details \u00b6 In case you are wondering what the install command actually does, you can use the --explain flag to get some information about the variables used, and the steps that are executed during the install process (without actually doing anything): > bring install --explain binaries.fd --os darwin Task : installing package 'fd' Variables arch x86_64 origin: index defaults os apple-darwin origin: user input, from alias: darwin pkg binaries.fd origin: user input target ~/.local/bring origin: index defaults target_config -- no value -- transform -- no value -- version 8.1.1 origin: package defaults, from alias: latest Steps - installing pkg 'fd' - gathering file(s) for package 'fd' - downloading file: https://github.com/sharkdp/fd/releases/download/v8.1.1/fd-v8.1.1-x86_64-apple-darwin.tar.gz - extracting archive (disregarding root folder, only using contents of it) - validating package content - merging files into folder '~/.local/bring'","title":"Installing packages"},{"location":"getting-started/installing-packages/#install-a-package","text":"When you don't need a specific version of a package, you can install a package...","title":"Install a package"},{"location":"getting-started/installing-packages/#using-only-default-values","text":"To install one of the available packages without any customization, all you need to do is specify the full name for the package: > bring install binaries.fd Task : installing package 'fd' Variables arch x86_64 origin: index defaults os unknown-linux-gnu origin: index defaults, from alias: linux pkg binaries.fd origin: user input target ~/.local/bring origin: index defaults target_config -- no value -- transform -- no value -- version 8.1.1 origin: package defaults, from alias: latest Progress - installing pkg 'fd' -> done - gathering file ( s ) for package 'fd' -> done - downloading file: https://github.com/sharkdp/fd/releases/download/v8.1.1/fd-v8.1.1-x86_64-unknown-linux-gnu.tar.gz -> done - extracting archive ( disregarding root folder, only using contents of it ) -> done - validating package content -> done - merging files into folder '~/.local/bring' -> done Result: - merged items into ' /home/runner/.local/bring ': fd : merged bring always tries be as clear as possible as to what it is doing, which is why it prints the values it ends up using, as well as their origin. For example, as you can see from the output of that command, the fd binary file was installed into the local $HOME/.local/bring folder. This is because that is the default folder for the binaries index (check the 'explain' command documentation on how to get that information). In addition to the target default, that index also comes with a set of auto-generated default values that describe the OS and architecture of the system bring is running on (which is helpful to pick the right version of a binary, for example). In some cases the default target might not be suitable for you though. In that case, you can install the package...","title":"... using only default values"},{"location":"getting-started/installing-packages/#into-a-specific-folder","text":"If you need to install a package into a specific directory, use the --target parameter: > bring install --target /tmp/bring binaries.fd Task : installing package 'fd' Variables arch x86_64 origin: index defaults os unknown-linux-gnu origin: index defaults, from alias: linux pkg binaries.fd origin: user input target /tmp/bring origin: user input target_config -- no value -- transform -- no value -- version 8.1.1 origin: package defaults, from alias: latest Progress ... ... ... Result: - merged items into ' /tmp/bring ': fd : merged The target folder, as well as any intermediate ones, will be created in case they don't exist yet. If you don't specify the --target parameter, and the index does not have a default target set, the files will be copied into a temporary directory somewhere under ~/.local/share/bring/workspace/results/ : > bring install kubernetes.cert-manager Task : installing package 'cert-manager' ... ... ... Result: - merged items into ' /home/runner/.cache/bring/workspace/results/install__wpayo_gs ': cert-manager.yaml : merged To have more fine-grained control of the version of the package to install, you have to use the install command...","title":"... into a specific folder"},{"location":"getting-started/installing-packages/#with-arguments","text":"Packages often come in different flavours (e.g. which architecture, OS, etc.), as well as several versions, which can be specified in the install command after the package name. Depending on the index configuration, bring assumes certain default values which often make it so that no package arguments at all need to be provided. But, often it is advisable to specify the exact version of a package to install. If that is desired, you can use the --help parameter (after the package name) to get bring to display information about the supported arguments: > bring install binaries.fd --help Usage: bring install binaries.fd [OPTIONS] Options: --arch ARCH The architecture the binary is built for. --os OS The operating system to run on. --version VERSION The version of the package. -h, --help Show this message and exit. To check which values are allowed, the explain subcommand is often useful (like the one we used here ). To illustrate, the following is an example showing how to specifically install version '7.1.0' of the Mac OS X variant of fd : > bring install binaries.fd --version 7.1.0 --os darwin Task : installing package 'fd' Variables arch x86_64 origin: index defaults os apple-darwin origin: user input, from alias: darwin pkg binaries.fd origin: user input target ~/.local/bring origin: index defaults target_config -- no value -- transform -- no value -- version 7.1.0 origin: user input ... ... ... Result: - merged items into ' /home/runner/.local/bring ': fd : file exists, not merged","title":"... with arguments"},{"location":"getting-started/installing-packages/#install-details","text":"In case you are wondering what the install command actually does, you can use the --explain flag to get some information about the variables used, and the steps that are executed during the install process (without actually doing anything): > bring install --explain binaries.fd --os darwin Task : installing package 'fd' Variables arch x86_64 origin: index defaults os apple-darwin origin: user input, from alias: darwin pkg binaries.fd origin: user input target ~/.local/bring origin: index defaults target_config -- no value -- transform -- no value -- version 8.1.1 origin: package defaults, from alias: latest Steps - installing pkg 'fd' - gathering file(s) for package 'fd' - downloading file: https://github.com/sharkdp/fd/releases/download/v8.1.1/fd-v8.1.1-x86_64-apple-darwin.tar.gz - extracting archive (disregarding root folder, only using contents of it) - validating package content - merging files into folder '~/.local/bring'","title":"Install details"},{"location":"getting-started/overview/","text":"Information/Help \u00b6 Getting information : how to retrieve information about packages, indexes, and other items of interest Packages \u00b6 A bring package is metadata that describes how to get a specific version of a file or set of files onto your machine; those files are usually remote, and not managed by yourself. Installing packages : how to install a bring package Creating a package : how to create bring package descriptions Indexes \u00b6 An index is a collection that contains packages. It has a (namespaced) unique name; within an index packages are referred to by name. Thus, each package can be addressed by a single string of the format <index_name>.<package_name> , e.g.: binaries.fd , gitlab.bring-indexes.example-index.pandoc , ...","title":"Overview"},{"location":"getting-started/overview/#informationhelp","text":"Getting information : how to retrieve information about packages, indexes, and other items of interest","title":"Information/Help"},{"location":"getting-started/overview/#packages","text":"A bring package is metadata that describes how to get a specific version of a file or set of files onto your machine; those files are usually remote, and not managed by yourself. Installing packages : how to install a bring package Creating a package : how to create bring package descriptions","title":"Packages"},{"location":"getting-started/overview/#indexes","text":"An index is a collection that contains packages. It has a (namespaced) unique name; within an index packages are referred to by name. Thus, each package can be addressed by a single string of the format <index_name>.<package_name> , e.g.: binaries.fd , gitlab.bring-indexes.example-index.pandoc , ...","title":"Indexes"}]}